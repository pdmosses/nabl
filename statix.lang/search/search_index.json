{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This website is a hyperlinked twin of a Spoofax project repository.</p> <p>The icons  and  toggle between light and dark mode.</p> <p>Hyperlinked twins support precise name-based code navigation using ordinary web browsers:</p> <ul> <li>Simply click on a name reference to jump to the corresponding declaration.</li> <li>Click on a declaration to jump to the first reference to it (if any).</li> <li>When the references are in multiple files,   clicking on the declaration displays a modal with a link to the first reference in each file.</li> </ul> <p>The sources of the webpages were generated by Spoofax from raw code, in the same way as for other hyperlinked twins.</p> <p>The aim is for a future release of Spoofax to support generation of hyperlinked twins for code in all Spoofax meta-languages.</p> <p>Warning</p> <p>The Spoofax implementation and the generated website have not yet been reviewed by the Spoofax developers.</p>"},{"location":"statix.lang/","title":"Statix","text":"<p>Statix is a meta-language for the specification of static semantics in Spoofax.</p> <p>Statix specifications are organised in modules. In Statix, programs, types and all other data are represented using terms. Type-checking a program is performed by solving a set of constraints over terms. In addition to these built-in constraints, specification writers can define their own constraints.</p> <p>Type-checking is closely related to, and strongly intertwined with, name resolution. For that reason, Statix has built-in support for modelling name binding patterns in the form of scope graphs. During type-checking, names can be resolved using queries.</p> <p>The Statix documentation explains the details.</p> <p>Statix supersedes the deprecated NaBL and NaBL2 meta-languages.</p> <p>Statix has not yet been used in Spoofax 2 for specifying the name binding of meta-languages. It has however been used for specifying languages in the MetaBorgCube, e.g., Tiger.</p>"},{"location":"statix.lang/#syntax","title":"Syntax","text":"<p><code>syntax/StatixLang.sdf3</code></p> <p>The syntax of Statix is specified in SDF3.</p>"},{"location":"statix.lang/#name-binding","title":"Name binding","text":"<p>The name binding of Statix is specified in NaBL2.<sup>1</sup></p> <ol> <li> <p>The name binding of NaBL2 definitions has not been specified, so browsing them is not supported by hyperlinked twins.\u00a0\u21a9</p> </li> </ol>"},{"location":"statix.lang/src-gen/syntax/permissive-water.sdf3/","title":"<code>permissive-water.sdf3</code>","text":"<pre><code>module permissive-water\n\n// Key idea: WATER is the inverse of LAYOUT\n\ncontext-free syntax\n  // Allow WATER on places where LAYOUT may occur\n  LAYOUT.WATER = WATER\n\nlexical sorts\n  WATER\n  WATERTOKEN\n  WATERTOKENSTART\n  WATERTOKENSEPARATOR\n\nlexical syntax\n  // Separate water regions into smaller chunks for recovery costs calculation\n  WATER = WATERTOKEN\n  WATER = WATERTOKENSEPARATOR\n\n  // Allow to skip over identifier strings\n  WATERTOKEN      = WATERTOKENSTART [A-Za-z0-9\\_]*\n  WATERTOKENSTART = [A-Za-z0-9\\_] {recover}\n\n  // Allow to skip over special characters that are neither part of identifiers nor whitespace characters\n  WATERTOKENSEPARATOR = ~[A-Za-z0-9\\_\\ \\t\\12\\r\\n\\*] {recover}\n\nlexical restrictions\n  WATERTOKEN -/- [A-Za-z0-9\\_]\n</code></pre> \u00d7"},{"location":"statix.lang/src-gen/syntax/permissive-water.sdf3/#modal-h2","title":"permissive-water.sdf3","text":""},{"location":"statix.lang/syntax/StatixLang.sdf3/","title":"<code>StatixLang.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/StatixLang.sdf3</p> <pre><code>module StatixLang\n\nimports\n\n  statix/lang/Layout\n  statix/lang/Common\n  statix/lang/Core\n  statix/lang/Sugar\n  statix/lang/PreCompiled\n  statix/lang/Deprecated\n\n  statix/test/Test\n\n  statix/cli/CLI\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\ncontext-free start-symbols\n\n  Start\n\n  LabelRE // for testing\n\ncontext-free syntax\n\n  Start = Module\n  Start = Test\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/StatixLang.sdf3/#modal-h2","title":"StatixLang.sdf3","text":""},{"location":"statix.lang/syntax/statix/cli/CLI.sdf3/","title":"<code>CLI.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/cli/CLI.sdf3</p> <pre><code>module statix/cli/CLI\n\nimports\n\n  statix/lang/Layout\n  statix/lang/Common\n  statix/lang/Core\n  statix/lang/Sugar\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\ncontext-free start-symbols\n\n  CommandLine\n\ncontext-free syntax\n\n  CommandLine.Eval = &lt;&lt;Constraint&gt;&gt;\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/cli/CLI.sdf3/#modal-h2","title":"CLI.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Common.sdf3/","title":"<code>Common.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Common.sdf3</p> <pre><code>module statix/lang/Common\n\nlexical syntax\n\n  INT = [0-9]+\n\n  ID     = [a-zA-Z] [a-zA-Z0-9\\_]*\n  UCID   = [A-Z]    [a-zA-Z0-9\\_]*\n  LCID   = [a-z]    [a-zA-Z0-9\\_]*\n  VARID  = [a-zA-Z] [a-zA-Z0-9\\_]* [\\']*\n\n  // more liberal ID to accept most Stratego sort and op identifiers\n  STRID = [A-Z] [a-zA-Z0-9\\_\\-\\']*\n//STRID = [a-z] [a-zA-Z0-9\\_\\-\\']* // leads to ambiguities with COp\n\n  FileId   = [a-zA-Z0-9\\_\\-\\.\\~\\']+\n  ModuleId = FileId (\"/\" FileId)*\n\nlexical restrictions\n\n  ID    -/- [a-zA-Z0-9\\_\\']\n  UCID  -/- [a-zA-Z0-9\\_\\']\n  LCID  -/- [a-zA-Z0-9\\_\\']\n  VARID -/- [a-zA-Z0-9\\_\\']\n\n  STRID -/- [a-zA-Z0-9\\_\\-\\']\n\n  FileId   -/- [a-zA-Z0-9\\_\\-\\.\\~\\']\n  ModuleId -/- [\\/]\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Common.sdf3/#modal-h2","title":"Common.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Core.sdf3/","title":"<code>Core.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Core.sdf3</p> <pre><code>module statix/lang/Core\n\nimports\n\n  statix/lang/Common\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\n\n/******************************************************************\n * Modules                                                        *\n ******************************************************************/\n\ncontext-free syntax\n\n  Module.Module = &lt;\n    module &lt;ModuleId&gt;\n\n    &lt;{Section \"\\n\\n\"}*&gt;\n  &gt; {longest-match}\n\n  Section.Imports = &lt;\n    imports\n      &lt;{Import \"\\n\"}*&gt;\n  &gt;\n\n  Import.Import = ModuleId\n\n  Section.Signature = &lt;\n    signature\n\n      &lt;{Signature \"\\n\\n\"}*&gt;\n  &gt; {longest-match}\n\n  Section.Rules = &lt;\n    rules\n\n      &lt;{Rule \"\\n\\n\"}*&gt;\n  &gt; {longest-match}\n\nlexical syntax\n\n  ModuleId = Keyword {reject}\n\n  Keyword = \"module\" | \"imports\" | \"signature\" | \"rules\"\n\n\n/******************************************************************\n * User Constraints                                               *\n ******************************************************************/\n\ncontext-free syntax\n\n  Signature.Constraints = &lt;\n    constraints\n      &lt;{CDecl \"\\n\"}*&gt;\n  &gt; {longest-match}\n\n  CDecl.CDecl      = [[CInd][ConstraintId] : [Type]]\n\n  CInd.InductiveC   =\n  CInd.CoinductiveC = &lt;coinductive &gt;\n\n  Rule.Rule = &lt;\n    &lt;RuleName&gt;&lt;RuleHead&gt; :-\n      &lt;Constraint&gt;.\n  &gt;\n\n  RuleName.NoName = &lt;&gt;\n  RuleName.Name = &lt;\n    [&lt;STRID&gt;]\n  &gt;\n  RuleHead.C = [[ConstraintId]([{Term \", \"}*])]\n\n  Constraint.C = [[ConstraintId]([{Term \", \"}*])[Message]]\n\n  HoConstraint.LLam = &lt;{ &lt;{Term \", \"}*&gt; :- &lt;Constraint&gt; }&gt;\n\nlexical syntax\n\n  ConstraintId = LCID\n  ConstraintId = Keyword {reject}\n\n  Keyword = \"constraints\" | \"coinductive\"\n\n\n/******************************************************************\n * Base Constraints                                               *\n ******************************************************************/\n\ncontext-free syntax\n\n  Constraint.CTrue  = &lt;true&gt;\n  Constraint.CFalse = &lt;false&lt;Message&gt;&gt;\n\n  Constraint         = &lt;(&lt;Constraint&gt;)&gt; {bracket}\n\n  Constraint.CConj   = &lt;\n    &lt;Constraint&gt;,\n    &lt;Constraint&gt;\n  &gt; {right}\n\n  Constraint.CNew    = &lt;new &lt;{Var \" \"}+&gt;&gt;\n\n  Constraint.CEqual   = [[Term] == [Term][Message]]\n  Constraint.CInequal = [[Term] != [Term][Message]]\n\n  Constraint.CTry = [try { [Constraint] }[Message]]\n\n  Constraint.CExists = [\n    {[{Var \" \"}*]}\n      [Constraint]\n  ]\n\ncontext-free priorities\n\n  // Does this give longest-match behavior? Putting longest-match on CExists\n  // seemed to break parsing of exists with conj body in parenthesis.\n  Constraint.CConj &gt; Constraint.CExists\n\nlexical syntax\n\n  Keyword = \"true\" | \"false\" | \"new\" | \"try\"\n\n\n/******************************************************************\n * AST Constraints                                                *\n ******************************************************************/\n\ncontext-free syntax\n\n  Constraint.CAstId       = &lt;astId(&lt;Term&gt;, &lt;Term&gt;)&gt;\n  Constraint.CAstProperty = &lt;@&lt;TermOrTermIndex&gt;.&lt;AstProperty&gt; &lt;AstPropertyOp&gt; &lt;Term&gt;&gt;\n\n  AstProperty.Prop = AstPropertyId\n\n  AstPropertyOp.Set = \":=\"\n  AstPropertyOp.Add = \"+=\"\n\n  TermOrTermIndex = Var\n\nlexical syntax\n\n  AstPropertyId = ID\n  AstPropertyId = Keyword {reject}\n\n  Keyword = \"astId\"\n\n\n/******************************************************************\n * Relations                                                      *\n ******************************************************************/\n\ncontext-free syntax\n\n  Signature.Relations = &lt;\n    relations\n      &lt;{RelDecl \"\\n\"}*&gt;\n  &gt; {longest-match}\n\n  RelDecl.RelDecl = &lt;&lt;Label&gt; : &lt;Type&gt;&gt;\n\n  RelRef = Label\n\n  Rule = &lt;relation &lt;RelDecl&gt;&gt;\n\nsyntax\n\n  Constraint-CF.CTellRel = \"!\" RelRef-CF \"[\" CommaTerms-CF \"]\" LAYOUT?-CF \"in\" LAYOUT?-CF Term-CF\n\nlexical syntax\n\n  RelationId = ID\n  RelationId = Keyword {reject}\n\n  Keyword = \"relations\" | \"relation\" | \"in\"\n\n\n/******************************************************************\n * Scope Graph                                                    *\n ******************************************************************/\n\ncontext-free syntax\n\n  Signature.NameResolution = &lt;\n    name-resolution\n      &lt;{ResolutionParam \"\\n\"}*&gt;\n  &gt; {longest-match}\n\n  // labels\n\n  ResolutionParam.Labels = &lt;labels &lt;{Label \" \"}*&gt;&gt;\n\n  Label.Label = RelationId\n\n  EdgeRef     = Label\n  EdgeRef.EOP = \"$\"\n\n  LabelPairs          = &lt;&lt;{LabelPair \", \"}*&gt;&gt;\n  LabelPair.LabelPair = [[EdgeRef] &lt; [EdgeRef]]\n  LabelOrd            = LabelPairs\n\n  LabelRE.Empty      = &lt;0&gt;\n  LabelRE.Epsilon    = &lt;e&gt;\n//LabelRE.Any        = &lt;.&gt;\n  LabelRE            = Label\n  LabelRE.Closure    = &lt;&lt;LabelRE&gt;*&gt;\n  LabelRE.Neg        = &lt;~&lt;LabelRE&gt;&gt;\n  LabelRE.Concat     = &lt;&lt;LabelRE&gt; &lt;LabelRE&gt;&gt;     {right}\n  LabelRE.And        = &lt;&lt;LabelRE&gt; &amp; &lt;LabelRE&gt;&gt;   {left}\n  LabelRE.Or         = &lt;&lt;LabelRE&gt; | &lt;LabelRE&gt;&gt;   {left}\n  LabelRE            = &lt;(&lt;LabelRE&gt;)&gt;             {bracket}\n\ncontext-free priorities\n\n    { LabelRE.Neg LabelRE.Closure }\n  &gt; LabelRE.Concat\n  &gt; LabelRE.And\n  &gt; LabelRE.Or\n\ncontext-free syntax\n\n  Term = Path\n\n  Path = PathLit\n\nsyntax\n\n  PathLit-CF.PathEmpty = \"_PathEmpty\" \"(\" LAYOUT?-CF Term-CF LAYOUT?-CF \")\"\n  PathLit-CF.PathStep  = \"_PathStep\" \"(\" LAYOUT?-CF Term-CF LAYOUT?-CF \",\" LAYOUT?-CF Term-CF LAYOUT?-CF \",\" LAYOUT?-CF Term-CF LAYOUT?-CF \")\"\n\n  Constraint-CF.CTellEdge = Term-CF LAYOUT?-CF \"-\" Label-CF \"-&gt;\" LAYOUT?-CF Term-CF\n\nlexical syntax\n\n  NamespaceId = UCID\n\n  RelationId = \"e\" {reject}        // ambiguous with empty regex\n  RelationId = Keyword {reject}    // ambiguous with signature keywords\n\n  Keyword = \"namespaces\" | \"name-resolution\" | \"labels\" | \"namespace\"\n\n\n/******************************************************************\n * Resolve &amp; Query\n ******************************************************************/\n\ncontext-free syntax\n\n  Constraint = CResolveQuery\n\n  CResolveQuery.CResolveQuery = [\n    query [QueryTarget]\n     [QueryFilter]\n     [QueryMin]\n     [QueryProject]\n      in [Term] |-&gt; [Term][Message]\n   ]\n\n  QueryTarget.EOP = \"()\"\n  QueryTarget     = RelRef\n\n  QueryFilter.Filter   = &lt; filter &lt;LabelRE&gt; and &lt;HoConstraint&gt;&gt;\n  QueryMin.Min         = &lt; min &lt;LabelOrd&gt; and &lt;HoConstraint&gt;&gt;\n  QueryProject.Project = &lt; project &lt;ProjectTarget&gt;&gt;\n\n  ProjectTarget.PFull       = &lt;*&gt;\n  ProjectTarget.PTargetData = &lt;dst, $&gt;\n  ProjectTarget.PData       = &lt;$&gt;\n\nlexical syntax\n\n  Keyword = \"query\" | \"in\" | \"filter\" | \"min\" | \"project\" | \"and\"\n\n\n/******************************************************************\n * Sorts &amp; Constructors                                           *\n ******************************************************************/\n\ncontext-free syntax\n\n  Signature.Sorts = &lt;\n    sorts\n      &lt;{SortDecl \"\\n\"}*&gt;\n  &gt; {longest-match}\n\n  Signature.Constructors = &lt;\n    constructors\n      &lt;{OpDecl \"\\n\"}*&gt;\n  &gt; {longest-match}\n\n  SortDecl.SortDecl  = SortId\n  SortDecl.SortAlias = &lt;&lt;SortId&gt; = &lt;SortRef&gt;&gt;\n\n  Sort.SimpleSort = SortId\n\n  SortRef                = Sort\n  SortRef.ListSort       = &lt;list(&lt;SortRef&gt;)&gt;\n  SortRef.Tuple0Sort     = &lt;( )&gt;\n  SortRef.TupleNSort     = &lt;(&lt;SortRef&gt; * &lt;{SortRef \" * \"}+&gt;)&gt;\n  SortRef.IntSort        = \"int\"\n  SortRef.StringSort     = \"string\"\n  SortRef.PathSort       = \"path\"\n  SortRef.LabelSort      = \"label\"\n  SortRef.OccurrenceSort = \"occurrence\"\n  SortRef.ScopeSort      = \"scope\"\n  SortRef.AstIdSort      = \"astId\"\n  SortRef                = &lt;(&lt;SortRef&gt;)&gt; {bracket}\n\n  OpDecl.OpDecl  = &lt;&lt;OpId&gt; : &lt;OpSort&gt;&gt;\n\n  OpSort.ConstOp = Sort\n  OpSort.ArrowOp = [[{SortRef \" * \"}+] -&gt; [Sort]]\n\n  Type.SimpleType = [[{SortRef \" * \"}*]]\n\nlexical syntax\n\n  SortId = STRID\n  SortId = Keyword {reject}\n  SortId = \"list\" | \"int\" | \"string\" | \"occurrence\" | \"scope\" | \"path\" | \"label\" | \"astId\" {reject}\n\n  OpId = STRID\n  OpId = Keyword {reject}\n\n  Keyword = \"sorts\" | \"constructors\"\n\n\n/******************************************************************\n * Terms                                                          *\n ******************************************************************/\n\ncontext-free syntax\n\n  Var.Var = VARID\n  Var.Wld = &lt;_&gt;\n\n  Int.Int = INT\n\n  Term            = Var\n  Term            = Int\n  Term            = Str\n  Term.List       = &lt;[&lt;{Term \", \"}*&gt;]&gt;\n  Term.ListTail   = &lt;[&lt;{Term \", \"}*&gt;|&lt;Term&gt;]&gt;\n  Term.Tuple0     = &lt;( )&gt;\n  Term.TupleN     = &lt;(&lt;Term&gt;, &lt;{Term \", \"}+&gt;)&gt;\n  Term.As         = &lt;&lt;Var&gt;@&lt;Term&gt;&gt;\n  Term.Ascribe    = &lt;&lt;Term&gt; : &lt;SortRef&gt;&gt;\n  Term            = &lt;(&lt;Term&gt;)&gt; {bracket}\n\n  CommaTerms = &lt;&lt;{Term \", \"}*&gt;&gt;\n  SpaceTerms = &lt;&lt;{Term \" \"}*&gt;&gt;\n\ncontext-free priorities\n\n    Term.As\n  &gt; Term.Ascribe\n\nsyntax\n\n  Term-CF.Op         = OpId-LEX \"(\" LAYOUT?-CF CommaTerms-CF LAYOUT?-CF \")\"\n\n  Str-CF.Str        = \"\\\"\" StrChars-LEX \"\\\"\"\n\nlexical syntax\n\n  StrChars   = StrChar*\n  StrChar    = ~[\\\"\\\\\\t\\r\\n]\n  StrChar    =  \"\\\\\\\"\" | \"\\\\\\\\\" | \"\\\\t\" | \"\\\\r\" | \"\\\\n\"\n\nlexical restrictions\n\n  StrChars -/- ~[\\\"]\n\n\n/******************************************************************\n * Arithmetic                                                          *\n ******************************************************************/\n\nsyntax\n\n  Constraint-CF.CArith = ArithExp-CF LAYOUT?-CF \"#\" ArithOp-CF LAYOUT?-CF ArithExp-CF LAYOUT?-CF Message-CF\n\n  ArithOp-CF.Equal            = \"=\"\n  ArithOp-CF.NotEqual         = \"\\\\=\"\n  ArithOp-CF.GreaterThanEqual = \"&gt;=\"\n  ArithOp-CF.LessThanEqual    = \"=&lt;\"\n  ArithOp-CF.GreaterThan      = \"&gt;\"\n  ArithOp-CF.LessThan         = \"&lt;\"\n\ncontext-free syntax\n\n  ArithExp     = Int\n  ArithExp     = Var\n  ArithExp.Add = &lt;&lt;ArithExp&gt; + &lt;ArithExp&gt;&gt; {left}\n  ArithExp.Mul = &lt;&lt;ArithExp&gt; * &lt;ArithExp&gt;&gt; {left}\n  ArithExp.Sub = &lt;&lt;ArithExp&gt; - &lt;ArithExp&gt;&gt; {left}\n  ArithExp.Min = &lt;min(&lt;ArithExp&gt;, &lt;ArithExp&gt;)&gt;\n  ArithExp.Max = &lt;max(&lt;ArithExp&gt;, &lt;ArithExp&gt;)&gt;\n  ArithExp.Mod = &lt;&lt;ArithExp&gt; mod &lt;ArithExp&gt;&gt; {left}\n  ArithExp.Div = &lt;&lt;ArithExp&gt; div &lt;ArithExp&gt;&gt; {left}\n  ArithExp     = &lt;(&lt;ArithExp&gt;)&gt; {bracket}\n\ncontext-free priorities\n\n    {left: ArithExp.Mul ArithExp.Div ArithExp.Mod}\n  &gt; {left: ArithExp.Add ArithExp.Sub}\n\n\n/******************************************************************\n * Messages                                                       *\n ******************************************************************/\n\ncontext-free syntax\n\n  Message.NoMessage =\n  Message.Message   = &lt; | &lt;MessageKind&gt; &lt;MessageContent&gt; &lt;MessageOrigin&gt;&gt;\n\n  MessageKind.Error      = &lt;error&gt;\n  MessageKind.Warning    = &lt;warning&gt;\n  MessageKind.Note       = &lt;note&gt;\n\nsyntax\n\n  MessageContent-CF.Formatted = \"$[\" MessageContentPart-CF* \"]\"\n\n  MessageOrigin-CF.NoOrigin =\n  MessageOrigin-CF.Origin   = \"@\" Var-CF\n\ncontext-free syntax\n\n  MessageContent.NoMessage =\n  MessageContent           = Str\n\n  MessageContentPart.Term = &lt;[&lt;Term&gt;]&gt;\n  MessageContentPart.Text = MessageChars\n\nlexical syntax\n\n  MessageChars = MessageChar+\n  MessageChar  = ~[\\[\\]\\\\\\t\\r\\n]\n  MessageChar  = \"\\\\[\" | \"\\\\]\" | \"\\\\n\" | \"\\\\r\" | \"\\\\t\" | \"\\\\\\\\\"\n\nlexical restrictions\n\n  MessageChars -/- ~[\\[\\]]\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Core.sdf3/#modal-h2","title":"Core.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Deprecated.sdf3/","title":"<code>Deprecated.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Deprecated.sdf3</p> <pre><code>module statix/lang/Deprecated\n\nimports\n\n  statix/lang/Common\n  statix/lang/Core\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\n/******************************************************************\n * Filtering\n ******************************************************************/\n\ncontext-free syntax\n\n  QueryFilter.Filter_dep = &lt; filter pathMatch[&lt;LabelRE&gt;]&gt; {deprecated(\"Use 'filter RE' instead of 'filter pathMatch[RE]'\")}\n  QueryMin.Min_dep       = &lt; min pathLt[&lt;LabelPairs&gt;]&gt;    {deprecated(\"Use 'min LT' instead of 'min pathLt[LT]'\")}\n\n  QueryFilter.Filter_dep = &lt; filter pathMatch[&lt;LabelRE&gt;] and &lt;HoConstraint&gt;&gt; {deprecated(\"Use 'filter RE' instead of 'filter pathMatch[RE]'\")}\n  QueryMin.Min_dep       = &lt; min pathLt[&lt;LabelPairs&gt;] and &lt;HoConstraint&gt;&gt;    {deprecated(\"Use 'min LT' instead of 'min pathLt[LT]'\")}\n\n  NamespaceFilter.NamespaceFilter_dep = &lt; filter pathMatch[&lt;LabelRE&gt;]&gt; {deprecated(\"Use 'filter RE' instead of 'filter pathMatch[RE]'\")}\n  NamespaceMin.NamespaceMin_dep       = &lt; min pathLt[&lt;LabelPairs&gt;]&gt;    {deprecated(\"Use 'min LT' instead of 'min pathLt[LT]'\")}\n\n/******************************************************************\n * Scope Graph creation\n ******************************************************************/\n\ncontext-free syntax\n\n  // namespaces\n  Signature.Namespaces = &lt;\n    namespaces\n      &lt;{NsDecl \"\\n\"}*&gt;\n  &gt; {longest-match, deprecated(\"Usage of namespaces is strongly discouraged.\")}\n\n  NsDecl.NsDecl = &lt;&lt;NamespaceId&gt; : &lt;{SortRef \" * \"}*&gt;&gt; {deprecated(\"Usage of namespaces is strongly discouraged.\")}\n\n  Rule = &lt;namespace &lt;NsDecl&gt;&gt;\n\n  // default resolution policies\n  NamespaceQuery.NamespaceQuery = &lt;resolve &lt;NamespaceId&gt;&lt;NamespaceFilter&gt;&lt;NamespaceMin&gt;&gt; {deprecated(\"Namespaces might be removed in a future version.\")}\n\n  ResolutionParam = NamespaceQuery\n  Rule            = NamespaceQuery\n\n  NamespaceFilter.NamespaceFilter   = &lt; filter &lt;LabelRE&gt;&gt;\n  NamespaceFilter.NoNamespaceFilter =\n\n  NamespaceMin.NamespaceMin   = &lt; min &lt;LabelPairs&gt;&gt;\n  NamespaceMin.NoNamespaceMin =\n\n  Constraint.CTellDecl         = [[Term] -&gt; [Occurrence]] {deprecated(\"Occurrences might be removed in a future version. Use `!rel[...]` syntax instead.\")}\n  Constraint.CTellDeclWithRels = [[Term] -&gt; [Occurrence] with [{RelData \" and \"}+]] {deprecated(\"Occurrences might be removed in a future version. Use `!rel[...]` syntax instead.\")}\n\n  RelData = [[RelRef] [Term]]\n\n/******************************************************************\n * Resolve &amp; Query\n ******************************************************************/\n\ncontext-free syntax\n\n  Constraint.CResolveRef        = [[Occurrence] in [Term] |-&gt; [Term][Message]]             {deprecated(\"Occurrences might be removed in a future version. Use `query` syntax instead.\")}\n  Constraint.CResolveRefWithRel = [[RelRef] of [Occurrence] in [Term] |-&gt; [Term][Message]] {deprecated(\"Occurrences might be removed in a future version. Use `query` syntax instead.\")}\n\n  // little duplication to fix ambiguity between\n  // As(Var(_),Var(_)), NoId() and Var(_), WithId(Var(_))\n  OccurrenceTerm  = Term {longest-match}\n  OccurrenceTerm  = &lt;&lt;Var&gt;@&lt;Term&gt;&gt; {reject}\n  OccurrenceTerms = &lt;&lt;{OccurrenceTerm \" \"}*&gt;&gt;\n\n  Term = Occurrence\n\n  Occurrence = OccurrenceLit // this indirection is necessary to solve parse errors\n\nsyntax\n\n  OccurrencePosition-CF.NoId   =\n  OccurrencePosition-CF.WithId = \"@\" TermOrTermIndex-CF\n  OccurrencePosition-CF.NoId   = \"@-\"\n\n  OccurrenceLit-CF.StxOccurrence = NamespaceId-LEX \"{\" LAYOUT?-CF OccurrenceTerms-CF LAYOUT?-CF OccurrencePosition-CF LAYOUT?-CF \"}\" {deprecated(\"Usage of occurrences is strongly discouraged.\")}\n\n  LabelRE-CF.ResolveMatch = \"resolveMatch\" \"[\" LAYOUT?-CF Occurrence-CF LAYOUT?-CF  \"]\"           {deprecated(\"Occurrences might be removed in a future version.\")}\n\n  LabelOrd-CF.ResolveLt = \"resolveLt\" \"[\" LAYOUT?-CF Occurrence-CF LAYOUT?-CF \"]\"                 {deprecated(\"Occurrences might be removed in a future version.\")}\n\n  HoConstraint-CF.OccurrenceMatch = \"occurrenceMatch\" \"[\" LAYOUT?-CF Occurrence-CF LAYOUT?-CF \"]\" {deprecated(\"Occurrences might be removed in a future version.\")}\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Deprecated.sdf3/#modal-h2","title":"Deprecated.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Layout.sdf3/","title":"<code>Layout.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Layout.sdf3</p> <pre><code>module statix/lang/Layout\n\nlexical syntax\n\n  LAYOUT = [\\t\\ \\r\\n]\n  LAYOUT = LineComment\n  LAYOUT = BlockComment\n\n  EOF =  \n\n  LineComment     = \"//\" ~[\\r\\n]* ([\\r\\n] | EOF)\n\n  BlockComment    = \"/*\" CommentText (BlockComment CommentText)* (\"*/\" | EOF)\n  CommentText     = CommentChar*\n  CommentChar     = ~[\\*\\/] | CommentAsterisk | CommentSlash\n  CommentSlash    = \"/\"\n  CommentAsterisk = \"*\"\n\nlexical restrictions\n\n  EOF             -/- ~[]\n  CommentText     -/- ~[\\*\\/]\n  CommentAsterisk -/- [\\/]\n  CommentSlash    -/- [\\*]\n\ncontext-free restrictions\n\n  LAYOUT? -/- [\\ \\t\\r\\n]   // whitespace\n  LAYOUT? -/- [\\/].[\\/]    // line comment start\n  LAYOUT? -/- [\\/].[\\*]    // block comment start\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Layout.sdf3/#modal-h2","title":"Layout.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/NoParse.sdf3/","title":"<code>NoParse.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/NoParse.sdf3</p> <pre><code>module statix/lang/NoParse // DO NOT INCLUDE IN OTHER SYNTAX FILES\n\nimports\n\n  statix/lang/Common\n  statix/lang/Core\n  statix/lang/Sugar\n\n  statix/API\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\ncontext-free syntax // desugared terms\n\n  Term.Tuple = &lt;(&lt;{Term \", \"}*&gt;)&gt;\n\n  SortRef.TupleSort = &lt;(&lt;{SortRef \" * \"}*&gt;)&gt;\n\n  Lift.TupleLift = &lt;(&lt;{Lift \", \"}*&gt;)&gt;\n\ncontext-free syntax // runtime terms\n\n  Term = Label\n  Term = Stx-Scope\n  Term = Stx-TermIndex\n\n  TermOrTermIndex = Stx-TermIndex\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/NoParse.sdf3/#modal-h2","title":"NoParse.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/PreCompiled.sdf3/","title":"<code>PreCompiled.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/PreCompiled.sdf3</p> <pre><code>module statix/lang/PreCompiled\n\nimports\n\n  statix/lang/Common\n  statix/lang/Core\n\nlexical sorts\n\n  ENVID\n\ncontext-free sorts\n\n  PreCompiledQuery\n\n  State\n  StateId\n  StateRef\n\n  RStep\n  RExp\n  RVar\n  RCond\n\nlexical syntax\n\n  ENVID = [a-zA-Z] [a-zA-Z0-9\\$\\_\\-]*\n\nlexical restrictions\n\n  ENVID -/- [a-zA-Z0-9\\$\\_\\-]\n\ncontext-free syntax\n\n  Constraint.CPreCompiledQuery = [\n    compiled [CResolveQuery]\n    to\n      states\n        [{State \"\\n\\n\"}*]\n\n      initial [StateRef]\n  ]\n\n\ncontext-free syntax // States\n\n  State.State = &lt;\n    &lt;StateId&gt;:\n      &lt;{RStep \"\\n\"}+&gt;\n      return &lt;RVar&gt;\n  &gt;\n\n  StateId  = LCID\n  StateRef = LCID\n\ncontext-free syntax // Resolution steps\n\n  RStep.Step     = &lt;&lt;RVar&gt; := &lt;RExp&gt;&gt;\n\ncontext-free syntax // Resolution expressions\n\n  RExp.Resolve   = &lt;resolve&gt;\n\n  RExp.SubEnv    = &lt;subenv &lt;RelRef&gt; &lt;StateRef&gt;&gt;\n\n  RExp.Merge     = &lt;merge(&lt;{RVar \", \"}*&gt;)&gt;\n\n  RExp.Shadow    = &lt;shadow(&lt;RVar&gt;, &lt;RVar&gt;)&gt;\n\n  RExp.CExp      = &lt;if not empty &lt;RVar&gt; else &lt;RExp&gt;&gt;\n\n  RVar.RVar      = ENVID\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/PreCompiled.sdf3/#modal-h2","title":"PreCompiled.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Schema.sdf3/","title":"<code>Schema.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Schema.sdf3</p> <pre><code>module statix/lang/Schema\n\nimports\n  statix/lang/Common\n  statix/lang/Core\n\ncontext-free start-symbols\n\n  Schema\n\ncontext-free sorts\n\n  Schema\n\ncontext-free syntax\n\n  Schema.SGSchema = &lt;scope graph scheme\n    &lt;SGEdges&gt;\n\n    &lt;SGDecls&gt;\n\n    &lt;SchemaVars&gt;\n  &gt;\n\ncontext-free sorts\n  SGEdges\n  SGEdge\n\ncontext-free syntax\n\n  SGEdges.SGEdges = &lt;edges\n    &lt;{SGEdge \"\\n\"}*&gt;\n  &gt;\n\n  SGEdge.SGEdge = [{[{ScopeKindWithCard \", \"}*]} =[Label]=&gt; {[{ScopeKindWithCard \", \"}*]} in [RuleName]]\n\ncontext-free sorts\n\n  SGDecls\n  SGDecl\n  Data\n\ncontext-free syntax\n\n  SGDecls.SGDecls = &lt;decls\n    &lt;{SGDecl \"\\n\"}*&gt;\n  &gt;\n\n  SGDecl.SGDecl = [{[{ScopeKindWithCard \", \"}*]} |=[Label]=&gt; \\[[{Data \", \"}*]\\] in [RuleName]]\n\n  Data.DData  = &lt;data&gt;\n  Data.DScope = [scope {[{ScopeKindWithCard \", \"}*]}]\n\ncontext-free sorts\n\n  SchemaVars\n  SchemaVar\n\ncontext-free syntax\n\n  SchemaVars.SchemaVars = &lt;schema variables\n    &lt;{SchemaVar \"\\n\"}*&gt;\n  &gt;\n\n  SchemaVar.SchemaVar = [[ScopeKindVar] |-&gt; {[{ScopeKindWithCard \",\"}*]}]\n\ncontext-free sorts\n\n  ScopeKind\n  ScopeKindVar\n  ScopeKindWithCard\n\ncontext-free syntax\n\n  ScopeKind.Glob         = &lt;glob&gt;\n  ScopeKind.KVar         = &lt;var &lt;Var&gt;&gt;\n  ScopeKind.Unknown      = &lt;unknown&gt;\n\n  ScopeKindVar.Variable  = &lt;var &lt;Var&gt;&gt;\n  ScopeKindVar.PArg      = &lt;prd &lt;ConstraintId&gt;[&lt;INTT&gt;]&gt;\n  ScopeKindVar.CArg      = &lt;ctr &lt;SortId&gt;[&lt;INTT&gt;]&gt;\n  ScopeKindVar.RArg      = &lt;rel &lt;Label&gt;[&lt;INTT&gt;]&gt;\n\n  ScopeKindWithCard.ScopeKindWithCard = &lt;&lt;ScopeKind&gt;[&lt;Cardinality&gt;]&gt;\n\ncontext-free sorts\n\n  Cardinality\n  Bound\n\ncontext-free syntax\n\n  Cardinality.Cardinality = &lt;&lt;Bound&gt;..&lt;Bound&gt;&gt;\n  Bound.INF               = &lt;*&gt;\n  Bound.BNum              = &lt;&lt;INTT&gt;&gt;\n\nlexical sorts\n  INTT\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Schema.sdf3/#modal-h2","title":"Schema.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Sugar.sdf3/","title":"<code>Sugar.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Sugar.sdf3</p> <pre><code>module statix/lang/Sugar\n\nimports\n\n  statix/lang/Common\n  statix/lang/Core\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\n\n/******************************************************************\n * User Constraints                                               *\n ******************************************************************/\n\ncontext-free syntax\n\n  // lifting of constraints\n\n  Rule             = &lt;constraint &lt;CDerive&gt;&gt;\n  Rule             = CDerive\n\n  Rule.CDecl       = [[CInd]constraint [ConstraintId] : [Type]]\n  Rule.CDecl       = [[CInd][ConstraintId] : [Type]]\n\n  CDecl            = CDerive\n\n  CDerive.CDeriveMap = [[ConstraintId] maps [ConstraintId]([{Lift \", \"}*])]\n  CDerive.FDeriveMap = [[ConstraintId] maps [ConstraintId]([{Lift \", \"}*]) = [Lift]]\n\n  Lift.IdLift     = \"*\"\n  Lift.ListLift   = \"list(*)\"\n  Lift.Tuple0Lift = &lt;( )&gt;\n  Lift.TupleNLift = &lt;(&lt;Lift&gt;, &lt;{Lift \", \"}+&gt;)&gt;\n\n  // rule shorthands\n\n  Rule.AxiomRule = &lt;\n    &lt;RuleName&gt;&lt;RuleHead&gt;.\n  &gt;\n\n  RuleHead.F = [[ConstraintId]([{Term \", \"}*]) = [Term]]\n\n  HoConstraint.LLam = &lt;{ &lt;{Term \", \"}+&gt; }&gt;\n\n  HoConstraint.LC = ConstraintId\n\n  HoConstraint.EQ = &lt;eq(&lt;Term&gt;)&gt;\n\nsyntax\n\n  Term-CF.COp = ConstraintId-CF \"(\" LAYOUT?-CF CommaTerms-CF LAYOUT?-CF \")\"\n\nlexical syntax\n\n  Keyword = \"constraint\" | \"maps\"\n\n\n/******************************************************************\n * Base Constraints                                               *\n ******************************************************************/\n\ncontext-free syntax\n\n  HoConstraint.LTrue  = \"true\"\n  HoConstraint.LFalse = \"false\"\n\n  Term.NewOp   = \"new\"\n  Term.AstIdOp = &lt;astId(&lt;Term&gt;)&gt;\n\n  AstProperty.Ref  = \"ref\"\n  AstProperty.Type = \"type\"\n\nlexical syntax\n\n  VARID = \"new\" {reject}\n\n  AstPropertyId = \"ref\" | \"type\" {reject}\n\n\n/******************************************************************\n * Relations                                                      *\n ******************************************************************/\n\ncontext-free syntax\n\n  RelRef.Decl = \"decl\"\n\nsyntax\n\n  // short-hand for querying relations\n\n  Constraint-CF.CAskRel  = \"?\" RelRef-CF \"[\" CommaTerms-CF \"]\" LAYOUT?-CF \"in\" LAYOUT?-CF Term-CF LAYOUT?-CF Message-CF\n\n  Term-CF.AskRelOp = \"?\" RelRef-CF \"[\" LAYOUT?-CF CommaTerms-CF LAYOUT?-CF \"]\" LAYOUT?-CF \"in\" LAYOUT?-CF Term-CF\n\nlexical syntax\n\n  RelationId = \"decl\" {reject}\n  RelationId = \"ref\" {reject}\n\n\n/******************************************************************\n * Scope Graph                                                    *\n ******************************************************************/\n\ncontext-free syntax\n\n  LabelRE.ZeroOrOne = &lt;&lt;LabelRE&gt;?&gt;\n  LabelRE.OneOrMore = &lt;&lt;LabelRE&gt;+&gt;\n\ncontext-free priorities\n\n    { LabelRE.Neg LabelRE.Closure LabelRE.ZeroOrOne LabelRE.OneOrMore }\n  &gt; { LabelRE.Concat LabelRE.And LabelRE.Or }\n\nlexical syntax\n\n  Keyword = \"resolve\" | \"filter\" | \"with\" | \"and\"\n\n\n/******************************************************************\n * Resolve &amp; Query\n ******************************************************************/\n\ncontext-free syntax\n\n  // short-hand forms for occurrences using default resolution policies\n\n  QueryFilter.NoFilter =\n  QueryFilter.Filter   = &lt; filter &lt;LabelRE&gt;&gt;\n\n\n  QueryMin.NoMin =\n  QueryMin.Min   = &lt; min &lt;LabelOrd&gt;&gt;\n\n\n  QueryProject.NoProject =\n\nlexical syntax\n\n  Keyword = \"filter\" | \"min\" | \"in\" | \"of\" | \"resolveMatch\" | \"resolveLt\" | \"occurrenceMatch\"\n\n\n/******************************************************************\n * Sorts &amp; Constructors                                           *\n ******************************************************************/\n\ncontext-free syntax\n\n  Type.FunType    = [[{SortRef \" * \"}*] -&gt; [SortRef]]\n\n\n/******************************************************************\n * Terms                                                          *\n ******************************************************************/\n\n\n/******************************************************************\n * Arithmetic                                                          *\n ******************************************************************/\n\nsyntax\n\n  Term-CF.ArithOp = \"#\" \"(\" LAYOUT?-CF ArithExp-CF LAYOUT?-CF \")\"\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Sugar.sdf3/#modal-h2","title":"Sugar.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Type.sdf3/","title":"<code>Type.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Type.sdf3</p> <pre><code>module statix/lang/Type\n\nimports\n\n  nabl2/API\n\n  statix/lang/Common\n  statix/lang/Core\n\n  statix/API\n\nsorts\n\n  IType // internal type\n  TType // term type\n\ncontext-free syntax\n\n  IType.PRED = [[TTypes]]\n  IType.FUN  = [[TTypes] -&gt; [TType]]\n  IType.NS   = [[TTypes]]\n  IType.OP   = [[TTypes] -&gt; [TType]]\n\n  TTypes = {TType \" * \"}*\n\n  TType.SORT       = &lt;&lt;NaBL2Occurrence&gt;&gt;\n  TType.INT        = &lt;int&gt;\n  TType.STRING     = &lt;string&gt;\n  TType.PATH       = &lt;path&gt;\n  TType.LABEL      = &lt;label&gt;\n  TType.OCCURRENCE = &lt;occurrence&gt;\n  TType.AST_ID     = &lt;astId&gt;\n  TType.SCOPE      = &lt;scope&gt;\n  TType.LIST       = &lt;list(&lt;TType&gt;)&gt;\n  TType.TUPLE      = &lt;(&lt;TTypes&gt;)&gt;\n\nsorts\n\n  ExtOrigin // custom prettyprint rule in statix/lang/scope-extension.str\n\ncontext-free syntax\n\n  ExtConstraints = &lt;| &lt;{ExtConstraint \"\\n\"}*&gt;&gt;\n\n  ExtConstraint.ExtProvides  = [[ExtSet] ! [ExtSet][ExtOrigin]]\n  ExtConstraint.ExtRequires  = [[ExtSet] ? [ExtSet][ExtOrigin]]\n  ExtConstraint.ExtIsCovered = [[ExtSet] is closed[ExtOrigin]]\n  ExtConstraint.ExtProvidesEsc  = [[ExtSet] ^! [ExtSet][ExtOrigin]]\n  ExtConstraint.ExtRequiresEsc  = [[ExtSet] ^? [ExtSet][ExtOrigin]]\n\n\n  ExtSets = &lt;| &lt;{ExtSet \"\\n\"}*&gt;&gt;\n\n  ExtSet.ExtParam = [[ExtId].[Stx-INT]]\n  ExtSet.ExtVar   = [[ExtId]]\n  ExtSet.ExtLit   = [{[{ExtLabel \", \"}*]}]\n  ExtSet.ExtAll   = \"*\"\n  ExtSet.ExtNone  = \"0\"\n\n\n  ExtId.ExtRef  = &lt;ref &lt;NaBL2Occurrence&gt;&gt;\n  ExtId.ExtDecl = &lt;decl &lt;NaBL2Occurrence&gt;&gt;\n\n\n  ExtLabel = RelRef\n  ExtLabel = EdgeRef\n\n\n  ExtEqs = &lt;| &lt;{ExtEq \"\\n\"}*&gt;&gt;\n\n  ExtEq = [[ExtSet] := [ExtOp]]\n\n\n  ExtOp.Union        = [union([{ExtOp \", \"}*])]\n  ExtOp.Intersection = [isect([{ExtOp \", \"}*])]\n  ExtOp              = ExtSet\n\ncontext-free syntax\n\n  PatternConstraint.DistinctPatterns = &lt;distinct patterns &lt;{NaBL2Occurrence \", \"}*&gt;&gt;\n  PatternConstraint.NoDuplicatePatterns = &lt;patterns {&lt;{NaBL2Occurrence \", \"}*&gt;} do not duplicate {&lt;{NaBL2Occurrence \", \"}*&gt;} &lt;ExtOrigin&gt;&gt;\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Type.sdf3/#modal-h2","title":"Type.sdf3","text":""},{"location":"statix.lang/syntax/statix/test/Result.sdf3/","title":"<code>Result.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/test/Result.sdf3</p> <pre><code>module statix/test/Result\n\nimports\n\n  statix/API\n\n  statix/lang/Layout\n  statix/lang/Common\n  statix/lang/Core\n  statix/lang/Sugar\n  statix/lang/Deprecated\n\n  statix/runtime/ATerm\n  statix/runtime/ScopeGraph\n\n\ncontext-free syntax\n\n  TestResult.EvalResult = &lt;\n    &lt;Solution&gt;\n\n    errors\n      &lt;{EditorMessage \"\\n\"}*&gt;\n\n    warnings\n      &lt;{EditorMessage \"\\n\"}*&gt;\n\n    notes\n      &lt;{EditorMessage \"\\n\"}*&gt;\n  &gt;\n\n  Solution.Solution = &lt;\n    substitution\n      &lt;{SubstEntry \"\\n\"}*&gt;\n\n    &lt;Analysis&gt;\n  &gt;\n\ncontext-free syntax\n\n  // special pretty print rule in statix/runtime/pp to support printing blob analyses too\n\n  Analysis.Analysis = &lt;\n    analysis\n      &lt;Stx-ScopeGraph&gt;\n  &gt;\n\ncontext-free syntax\n\n  SubstEntry = [[Var] |-&gt; [Stx-ATerm]]\n\ncontext-free syntax\n\n  EditorMessage = [[MessagePos] : [Stx-STRING]]\n\n  MessagePos = \"*\"\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/test/Result.sdf3/#modal-h2","title":"Result.sdf3","text":""},{"location":"statix.lang/syntax/statix/test/Test.sdf3/","title":"<code>Test.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/test/Test.sdf3</p> <pre><code>module statix/test/Test\n\nimports\n\n  statix/lang/Layout\n  statix/lang/Common\n  statix/lang/Core\n  statix/lang/Sugar\n  statix/lang/Deprecated\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\ncontext-free start-symbols\n\n  Test\n\ncontext-free syntax\n\n  Test.Test = &lt;\n    resolve\n      &lt;Constraint&gt;\n\n    &lt;{Section \"\\n\\n\"}*&gt;\n  &gt;\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/test/Test.sdf3/#modal-h2","title":"Test.sdf3","text":""}]}