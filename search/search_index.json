{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This website is a hyperlinked twin of a Spoofax project repository.</p> <p>The icons  and  toggle between light and dark mode.</p> <p>Hyperlinked twins support precise name-based code navigation using ordinary web browsers:</p> <ul> <li>Simply click on a name reference to jump to the corresponding declaration.</li> <li>Click on a declaration to jump to the first reference to it (if any).</li> <li>When the references are in multiple files,   clicking on the declaration displays a modal with a link to the first reference in each file.</li> </ul> <p>The sources of the webpages were generated by Spoofax from raw code, in the same way as for other hyperlinked twins.</p> <p>The aim is for a future release of Spoofax to support generation of hyperlinked twins for code in all Spoofax meta-languages.</p> <p>Warning</p> <p>The Spoofax implementation and the generated website have not yet been reviewed by the Spoofax developers.</p>"},{"location":"org.metaborg.meta.lang.nabl/","title":"NaBL","text":"<p>In Spoofax, name bindings can be specified in NaBL. NaBL stands for Name Binding Language and the acronym is pronounced 'enable'.</p> <p>Name binding is specified in NaBL in terms of:</p> <ul> <li>namespaces, </li> <li>binding instances (name declarations), </li> <li>bound instances (name references),</li> <li>scopes, and</li> <li>imports.</li> </ul> <p>The NaBL documentation explains the details.</p> <p>NaBL is now deprecated. It was originally superseded by NaBL2, and both have now been superseded by Statix.</p> <p>However, NaBL is still used in Spoofax 2 for specifying the name binding of several meta-languages (e.g., SDF3).</p>"},{"location":"org.metaborg.meta.lang.nabl/#syntax","title":"Syntax","text":"<p><code>syntax/NameBindingLanguage.sdf3</code></p> <p>The syntax of NaBL is specified in SDF3.</p>"},{"location":"org.metaborg.meta.lang.nabl/#name-binding","title":"Name binding","text":"<p><code>trans/analysis/names.nab</code></p> <p>The name binding of NaBL is specified in NaBL itself.</p> <p>This example demonstrates generation of a hyperlinked twin from a bootstrapped meta-language definition.</p>"},{"location":"org.metaborg.meta.lang.nabl/src-gen/syntax/permissive-water.sdf3/","title":"<code>permissive-water.sdf3</code>","text":"<pre><code>module permissive-water\n\n// Key idea: WATER is the inverse of LAYOUT\n\ncontext-free syntax\n  // Allow WATER on places where LAYOUT may occur\n  LAYOUT.WATER = WATER\n\nlexical sorts\n  WATER\n  WATERTOKEN\n  WATERTOKENSTART\n  WATERTOKENSEPARATOR\n\nlexical syntax\n  // Separate water regions into smaller chunks for recovery costs calculation\n  WATER = WATERTOKEN\n  WATER = WATERTOKENSEPARATOR\n\n  // Allow to skip over identifier strings\n  WATERTOKEN      = WATERTOKENSTART [A-Za-z0-9\\_]*\n  WATERTOKENSTART = [A-Za-z0-9\\_] {recover}\n\n  // Allow to skip over special characters that are neither part of identifiers nor whitespace characters\n  WATERTOKENSEPARATOR = ~[A-Za-z0-9\\_\\ \\t\\12\\r\\n\\*] {recover}\n\nlexical restrictions\n  WATERTOKEN -/- [A-Za-z0-9\\_]\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/src-gen/syntax/permissive-water.sdf3/#modal-h2","title":"permissive-water.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/NameBindingLanguage.sdf3/","title":"<code>NameBindingLanguage.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/NameBindingLanguage.sdf3</p> <pre><code>module NameBindingLanguage\n\nimports \n\n  common/Layout \n  common/Identifiers  \n  terms/Signatures  \n  terms/Terms \n  formulas/Formulas \n  formulas/Propositions \n  core/Modules  \n  core/Namespaces \n  core/Properties \n  terms/Vars\n\ncontext-free start-symbols\n\n  Start\n\ncontext-free syntax\n\n  Start = Module \n\ncontext-free syntax // namespaces\n\n  RestrictedNamespaceRef.Restricted = &lt;&lt;Restriction*&gt; &lt;NamespaceRef&gt;&gt; \n  Restriction.Imported = &lt;imported&gt; \n\ncontext-free syntax // properties\n\n  PropertyDef.QualityDef = &lt;\n  &lt;PropertyID&gt; of &lt;{NamespaceRef \", \"}+&gt;&gt;\n\n  QualityRef.QualityRef = &lt;&lt;PropertyID&gt;&gt;\n\n  PropertyTerm.PropertyTerm = &lt;of &lt;PropertyRef&gt; &lt;Term&gt;&gt;\n  PropertyTerm.QualityTerm = &lt;of quality &lt;QualityRef&gt;&gt;\n  PropertyPattern.PropertyPattern = &lt;of &lt;PropFilter&gt; &lt;PropertyRef&gt; &lt;Term&gt;&gt;\n  PropertyPattern.QualityPattern = &lt;of quality &lt;QualityRef&gt;&gt;\n\n  PropFilter.Equal = &lt;&gt; \n  PropFilter.Conformant = &lt;conformant&gt; \n\nlexical syntax\n\n  PropertyID = \"quality\" {reject}\n  SectionKeyword = \"binding\" \n\ncontext-free syntax // binding rules\n\n  ModuleSection.Bindings = &lt;\n  binding rules\n    &lt;BindingRule*&gt;\n  &gt; \n\n  BindingRule.BindingRule = &lt;\n  &lt;Pattern&gt; &lt;Constraints&gt; : &lt;BindingClause+&gt;&gt; \n\ncontext-free syntax // clauses\n\n  BindingClause.DefClause = &lt;\n    &lt;DefKind&gt; defines &lt;Unique&gt; &lt;NamespaceRef&gt; &lt;Term&gt; &lt;PropertyTerm*&gt; &lt;InDefScopes&gt; &lt;Constraints&gt;\n  &gt; \n\n  DefKind.Explicit = &lt;&gt; \n  DefKind.Implicit = &lt;implicitly&gt; \n\n  Unique.Unique = &lt;&gt; \n  Unique.Unique = &lt;unique&gt; \n  Unique.NonUnique = &lt;non-unique&gt; \n\n  BindingClause.ScopeClause = &lt;\n    scopes &lt;{NamespaceRef \", \"}+&gt;\n  &gt; \n\n  BindingClause.NonTransitiveScopeClause = &lt;\n    non-transitively scopes &lt;{NamespaceRef \", \"}+&gt;\n  &gt; \n\n  BindingClause.RefClause = &lt;\n    &lt;{RefClausePart \"otherwise\"}+&gt;\n  &gt; \n\n  RefClausePart.RefClausePart = &lt;\n  refers to &lt;Disambiguator&gt; &lt;NamespaceRef&gt; &lt;Term&gt; &lt;PropertyPattern*&gt; &lt;InRefScope&gt; &lt;Constraints&gt;&gt; \n\n  BindingClause.ImportClause = &lt;\n    &lt;{ImportClausePart \"otherwise\\n\"}+&gt;\n  &gt; \n\n  ImportClausePart.SingleImport = &lt;\n  imports &lt;Disambiguator&gt; &lt;NamespaceRef&gt; &lt;Term&gt; &lt;PropertyPattern*&gt; &lt;FromRefScope&gt; &lt;Alias&gt; &lt;IntoDefScopes&gt; &lt;Constraints&gt;&gt; \n  ImportClausePart.WildcardImport = &lt;\n  imports &lt;{RestrictedNamespaceRef \", \"}+&gt; &lt;PropertyPattern*&gt; &lt;FromRefScope&gt; &lt;IntoDefScopes&gt; &lt;Constraints&gt;&gt; \n\n  Alias.None = &lt;&gt; \n  Alias.Alias = &lt;as &lt;Term&gt;&gt; \n\n  BindingClause.FilterClause = &lt;\n    filters &lt;NamespaceRef&gt; &lt;Term&gt; \n      &lt;Filters&gt;\n      &lt;Constraints&gt;\n  &gt; \n\n  BindingClause.DisambiguateClause = &lt;\n    disambiguates &lt;NamespaceRef&gt; &lt;Term&gt;\n      &lt;Filters&gt;\n      by &lt;Disambiguator&gt; \n      &lt;Constraints&gt;\n   &gt; \n  Disambiguator.MinimalDistance = &lt;\n    minimal distance &lt;Term&gt; &lt;Relation&gt; &lt;Term&gt;\n  &gt; \n\ncontext-free syntax // scopes\n\n  InDefScopes.Current = &lt;&gt; \n  InDefScopes = &lt;in &lt;DefScopes&gt;&gt; {bracket}\n\n  IntoDefScopes.Current = &lt;&gt; \n  IntoDefScopes = &lt;into &lt;DefScopes&gt;&gt; {bracket}\n\n  DefScopes.Current = &lt;current scope&gt; \n  DefScopes.DefScopes = &lt;&lt;{DefScope \", \"}+&gt;&gt; \n  DefScope.Subsequent = &lt;subsequent scope&gt; \n  DefScope.DefScope = &lt;&lt;Term&gt;&gt; \n\n  InRefScope.Current = &lt;&gt; \n  InRefScope = &lt;in &lt;RefScope&gt;&gt; {bracket}\n\n  FromRefScope.Current = &lt;&gt; \n  FromRefScope = &lt;from &lt;RefScope&gt;&gt; {bracket}\n\n  RefScope.Current = &lt;current scope&gt; \n  RefScope.Enclosing = &lt;enclosing &lt;NamespaceRef&gt;&gt; \n  RefScope.Context = &lt;&lt;Disambiguator&gt; &lt;NamespaceRef&gt; &lt;Term&gt; &lt;PropertyPattern*&gt; &lt;InRefScope&gt;&gt; \n  RefScope.RefScope = &lt;&lt;Term&gt;&gt; \n\n  Disambiguator.All = &lt;&gt; \n  Disambiguator.Best = &lt;best&gt; \n\ncontext-free syntax // constraints\n\n  Constraints.NoWhere = &lt;&gt; \n  Constraints.Where = &lt;\n    where &lt;Formula&gt;\n  &gt; {bracket}\n\n  Filters.Filter = &lt;\n    with &lt;Formula&gt;\n  &gt; \n\n  Proposition.PropertyPattern = &lt;&lt;VarRef&gt; has &lt;PropertyRef&gt; &lt;Pattern&gt;&gt; {avoid}\n\nlexical syntax\n\n  Id = \"into\" {reject}\n  Id = \"enclosing\" {reject}\n\ntemplate options\n\n  keyword -/- [a-zA-z]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/NameBindingLanguage.sdf3/#modal-h2","title":"NameBindingLanguage.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/common/Identifiers.sdf3/","title":"<code>Identifiers.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/common/Identifiers.sdf3</p> <pre><code>module common/Identifiers\n\nsorts\n\n  Id LId LCID UCID\n\nlexical syntax\n\n  Id = [a-zA-Z\\_] [a-zA-Z0-9\\'\\-\\_]* \n  LId = [a-zA-Z\\_] [a-zA-Z0-9\\'\\-\\_]* \"*\" \n  Id = [\\'] [a-z]+ \n  LCID = [a-z] [a-zA-Z0-9\\'\\-\\_]* \n  UCID = [A-Z] [a-zA-Z0-9\\'\\-\\_]* \n\nlexical restrictions\n\n  Id -/- [a-zA-Z0-9\\'\\_\\*]\n  Id -/- [\\-].~[\\&gt;]\n  LId -/- [a-zA-Z0-9\\'\\-\\_]\n  LCID -/- [a-zA-Z0-9\\'\\-\\_]\n  UCID -/- [a-zA-Z0-9\\'\\-\\_]\n\nlexical syntax\n\n  Id = \"_\" {reject}\n  Id = \"'\" {reject}\n  Id = Keyword {reject}\n  LId = Keyword {reject}\n  LCID = Keyword {reject}\n  UCID = Keyword {reject}\n\nsorts\n\n  Keyword\n\nlexical syntax\n\n  Keyword = \"module\" \n  Keyword = \"rules\" \n  Keyword = \"namespaces\" \n  Keyword = \"properties\" \n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/common/Identifiers.sdf3/#modal-h2","title":"Identifiers.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/common/Layout.sdf3/","title":"<code>Layout.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/common/Layout.sdf3</p> <pre><code>module common/Layout\n\nsorts\n\n  LongCom CommChar Asterisk Eof\n\nlexical syntax\n\n  LAYOUT = [\\t\\ \\n\\r] \n  LAYOUT = \"//\" ~[\\n]* [\\n] | Eof \n  Eof =  \n  LAYOUT = LongCom \n  LongCom = \"/*\" CommChar* \"*/\" \n  CommChar = ~[\\*] \n  CommChar = Asterisk \n  Asterisk = \"*\" \n\nlexical restrictions\n\n  Asterisk -/- [\\/]\n  Eof -/- ~[]\n\ncontext-free restrictions\n\n  LAYOUT? -/- [\\ \\t\\n\\r]\n  LAYOUT? -/- [\\/].[\\*]\n  LAYOUT? -/- [\\/].[\\/]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/common/Layout.sdf3/#modal-h2","title":"Layout.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/core/Modules.sdf3/","title":"<code>Modules.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/core/Modules.sdf3</p> <pre><code>module core/Modules\n\ncontext-free syntax\n\n  Module.Module = &lt;module &lt;ModuleID&gt; \n\n    &lt;ModuleSection*&gt;&gt; \n\n  ModuleSection.Imports = &lt;\n    imports &lt;ImportModule*&gt;&gt; \n\n  ImportModule.ImportWildcard = &lt;&lt;ModuleID&gt;/-&gt; \n  ImportModule.Import = &lt;&lt;ModuleID&gt;&gt; \n\nlexical syntax\n\n  ModuleID = {ModuleIDPart \"/\"}+ \n  ModuleIDPart = [a-zA-Z\\.\\_] [a-zA-Z0-9\\'\\.\\-\\_]* \n  ModuleID = SectionKeyword {reject}\n\n  SectionKeyword = \"imports\" \n\nlexical restrictions\n\n  ModuleID -/- [a-zA-Z0-9\\'\\.\\-\\_]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/core/Modules.sdf3/#modal-h2","title":"Modules.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/core/Namespaces.sdf3/","title":"<code>Namespaces.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/core/Namespaces.sdf3</p> <pre><code>module core/Namespaces\n\nimports \n\n  common/Identifiers  \n  core/Modules\n\nlexical syntax\n\n  NamespaceID = Id \n  NamespaceID = SectionKeyword {reject}\n  SectionKeyword = \"namespaces\" \n\ncontext-free syntax\n\n  ModuleSection.Namespaces = &lt;\n  namespaces   \n    &lt;NamespaceDef*&gt;\n  &gt; \n\n  NamespaceDef.NamespaceDef = &lt;&lt;NamespaceID&gt;\n    &gt; \n\n  NamespaceRef.NamespaceRef = &lt;&lt;LanguageRef&gt;&lt;NamespaceID&gt;&gt; \n\n  LanguageRef.CurrentLanguage = &lt;&gt; \n  LanguageRef.LanguageRef = &lt;&lt;Id&gt;.&gt; \n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/core/Namespaces.sdf3/#modal-h2","title":"Namespaces.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/core/Properties.sdf3/","title":"<code>Properties.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/core/Properties.sdf3</p> <pre><code>module core/Properties\n\nimports\n\n        common/Identifiers  \n        terms/Signatures  \n        terms/Vars  \n        terms/Terms \n        formulas/Formulas \n        core/Namespaces\n\nlexical syntax\n\n  PropertyID = Id \n  PropertyID = \"type\" {reject}\n  PropertyID = SectionKeyword {reject}\n\n  SectionKeyword = \"properties\" \n\n  Relation = \"&lt;\" [A-Za-z\\-]* \":\" \n\ncontext-free syntax\n\n  ModuleSection.Properties = &lt;\n  properties   \n    &lt;PropertyDef*&gt;\n  &gt; \n\n  PropertyDef.PropertyDef = &lt;\n    &lt;PropertyID&gt; of &lt;{NamespaceRef \", \"}+&gt; : &lt;Sort&gt;&gt; \n\n  PropertyRef.TypeProp = &lt;type&gt; \n  PropertyRef.PropertyRef = &lt;&lt;PropertyID&gt;&gt; \n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/core/Properties.sdf3/#modal-h2","title":"Properties.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/core/Scopes.sdf3/","title":"<code>Scopes.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/core/Scopes.sdf3</p> <pre><code>module core/Scopes\n\nimports \n\n        common/Identifiers  \n        core/Namespaces \n        terms/Vars\n\nlexical syntax\n\n  ScopeID = Id \n\ncontext-free syntax\n\n  LocalScope.NamedScope = &lt;&lt;NamespaceRef&gt; &lt;VarRef&gt;&gt; \n  LocalScope.CurrentScope = &lt;current &lt;NamespaceRef&gt; scope&gt; \n  LocalScope.TermScope = &lt;&lt;NamespaceRef&gt; scope  at &lt;VarRef&gt;&gt; \n  LocalScope.Enclosing = &lt;enclosing &lt;NamespaceRef&gt; of &lt;LocalScope&gt;&gt; \n\n  Scope.GlobalScope = &lt;global scope&gt; \n  Scope = &lt;&lt;LocalScope&gt;&gt; \n  Scope.Anonymous = &lt;new scope in &lt;Scope&gt;&gt; \n\ncontext-free syntax\n\n  Clause.ChildScope = &lt;\n    &lt;Scope&gt; scopes &lt;NamespaceRef&gt; at child nodes\n  &gt; \n\n  Clause.SubsequentScope = &lt;\n    &lt;Scope&gt; scopes &lt;NamespaceRef&gt; at subsequent nodes\n  &gt; \n\n  Clause.NodeScope = &lt;\n    requires &lt;NamespaceRef&gt; scope at &lt;VarRef&gt;\n  &gt; \n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/core/Scopes.sdf3/#modal-h2","title":"Scopes.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/formulas/Formulas.sdf3/","title":"<code>Formulas.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/formulas/Formulas.sdf3</p> <pre><code>module formulas/Formulas\n\nimports \n\n  terms/Terms \n  formulas/Propositions\n\ncontext-free syntax\n\n  Formula = &lt;&lt;Proposition&gt;&gt; \n\n  Formula.Not = &lt;\n    not &lt;Formula&gt;\n  &gt; \n  Formula.And = &lt;\n    &lt;Formula&gt; \n    and &lt;Formula&gt;\n  &gt; {left}\n  Formula.Or = &lt;\n    &lt;Formula&gt; \n    or &lt;Formula&gt;\n  &gt; {left}\n\n  Formula = &lt;(&lt;Formula&gt;)&gt; {bracket}\n\ncontext-free priorities\n\n  Formula.Not &gt; Formula.And &gt; Formula.Or\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/formulas/Formulas.sdf3/#modal-h2","title":"Formulas.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/formulas/Messages.sdf3/","title":"<code>Messages.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/formulas/Messages.sdf3</p> <pre><code>module formulas/Messages\n\nimports\n\n  terms/Terms\n\ncontext-free syntax\n\n  Message.Message = &lt;&lt;MessageKind&gt; &lt;Term&gt; on &lt;Term&gt;&gt; \n\n  MessageKind.Error = &lt;error&gt; \n  MessageKind.Warning = &lt;warning&gt; \n  MessageKind.Note = &lt;note&gt; \n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/formulas/Messages.sdf3/#modal-h2","title":"Messages.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/formulas/Propositions.sdf3/","title":"<code>Propositions.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/formulas/Propositions.sdf3</p> <pre><code>module formulas/Propositions\n\nimports \n\n  terms/Terms \n  terms/Vars  \n  core/Namespaces \n  core/Scopes \n  core/Properties\n\ncontext-free syntax\n\n  Proposition.True = &lt;true&gt; \n  Proposition.False = &lt;false&gt; \n  Proposition.Eq = [[VarRef] == [Term]] \n\n  Proposition.Match = [[VarRef] =&gt; [Pattern]] \n  Proposition.DefOf = [definition of [VarRef] =&gt; [Var]] \n  Proposition.DefOf = [definition of [NamespaceRef] [VarRef] =&gt; [Var]] \n  Proposition.ScopeOf = [[Scope] =&gt; [Var]] \n  Proposition.ResolvesTo = &lt;&lt;Term&gt; resolves to &lt;NamespaceRef&gt; &lt;Var&gt;&gt; \n\n  Proposition.HasProperty = &lt;&lt;VarRef&gt; has &lt;PropertyRef&gt; &lt;Var&gt;&gt; \n  Proposition.InRelation = [[Term] [Relation] [Term]] \n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/formulas/Propositions.sdf3/#modal-h2","title":"Propositions.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/lexical/Identifiers.sdf3/","title":"<code>Identifiers.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/lexical/Identifiers.sdf3</p> <pre><code>module lexical/Identifiers\n\nsorts \n\n  Id LId LCID UCID ModuleID\n\nlexical syntax\n\n  Id  = [a-zA-Z\\_] [a-zA-Z0-9\\'\\-\\_]*    \n  Id  = \"_\" {reject}\n  Id  = [\\'] [a-z]+\n  LId = [a-zA-Z\\_] [a-zA-Z0-9\\'\\-\\_]* \"*\"\n\n  LCID = [a-z] [a-zA-Z0-9\\'\\-\\_]*\n  UCID = [A-Z] [a-zA-Z0-9\\'\\-\\_]*\n\n  ModuleID     = {ModuleIDPart \"/\"}+ \n  ModuleIDPart = [a-zA-Z\\.\\_] [a-zA-Z0-9\\'\\.\\-\\_]* \n\nlexical restrictions\n\n  Id       -/- [a-zA-Z0-9\\'\\_\\*]\n  Id       -/- [\\-].~[\\&gt;]\n  LId      -/- [a-zA-Z0-9\\'\\-\\_]\n  LCID     -/- [a-zA-Z0-9\\'\\-\\_]\n  UCID     -/- [a-zA-Z0-9\\'\\-\\_]\n  ModuleID -/- [a-zA-Z0-9\\'\\.\\-\\_]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/lexical/Identifiers.sdf3/#modal-h2","title":"Identifiers.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/lexical/Layout.sdf3/","title":"<code>Layout.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/lexical/Layout.sdf3</p> <pre><code>module lexical/Layout\n\nsorts LongCom CommChar Asterisk Eof \n\nlexical syntax\n\n  LAYOUT   = [\\t\\ \\n\\r] \n\n  LAYOUT   =\"//\" ~[\\n]* ([\\n] | Eof)\n  Eof      = \n\n  LAYOUT   = LongCom\n  LongCom  = \"/*\" CommChar* \"*/\"\n  CommChar = ~[\\*]\n  CommChar = Asterisk\n  Asterisk = \"*\"\n\nlexical restrictions\n\n  Asterisk -/- [\\/]\n  Eof      -/- ~[]\n\ncontext-free restrictions\n\n  LAYOUT? -/- [\\ \\t\\n\\r]\n  LAYOUT? -/- [\\/].[\\*]\n  LAYOUT? -/- [\\/].[\\/]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/lexical/Layout.sdf3/#modal-h2","title":"Layout.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/terms/Constants.sdf3/","title":"<code>Constants.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/terms/Constants.sdf3</p> <pre><code>module terms/Constants\n\nsorts \n\n  Int Real String StrChar\n\nlexical syntax\n\n  Int     = [\\-]? [0-9]+\n  Real    = [\\-]? [0-9]+ [\\.] [0-9]+\n  String  = \"\\\"\" StrChar* \"\\\"\"\n  StrChar = ~[\\\"\\\\]\n  StrChar = [\\\\] [\\\"tnr\\\\]\n\nsorts Char CharChar\n\nlexical syntax\n\n  Char     = \"'\" CharChar \"'\"\n  CharChar = ~[\\']\n  CharChar = [\\\\] [\\'ntr\\ ]\n\nlexical syntax\n\n  Id = Char {reject}\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/terms/Constants.sdf3/#modal-h2","title":"Constants.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/terms/Signatures.sdf3/","title":"<code>Signatures.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/terms/Signatures.sdf3</p> <pre><code>module terms/Signatures\n\nimports\n\n        common/Identifiers\n        terms/Constants\n\nsorts \n\n  Sort\n\ncontext-free syntax\n\n        Sort.SortVar    = LCID\n        Sort.SortNoArgs = UCID\n        Sort.Sort       = Id \"(\" {Sort \",\"}* \")\"\n\nsorts TypeDecl PPTerm\n\ncontext-free syntax\n\n  TypeDecl.TypeDecl  = Id     TypeParams PPTerm\n  TypeDecl.TypeDeclQ = String TypeParams PPTerm\n  PPTerm.Str         = String\n\nsorts TypeParams TypeParam \n\ncontext-free syntax\n\n  TypeParams.NoTypeParams =\n  TypeParams.TypeParams   = \"(\" {TypeParam \",\"}+ \")\"\n  TypeParam.TypeParam     = Id \":\" Sort\n\n%%%\n%% Restriction is required for the Sort* in Sdecl: List(a) is\n%% ambiguous.\n%%%\ncontext-free restrictions\n\n        Sort -/- [\\(]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/terms/Signatures.sdf3/#modal-h2","title":"Signatures.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/terms/StringQuotations.sdf3/","title":"<code>StringQuotations.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/terms/StringQuotations.sdf3</p> <pre><code>module terms/StringQuotations\n\nimports \n\n  terms/Terms\n\nsorts\n\n  PPTerm\n  StringQuotation\n  StringQuotedPart1 StringQuotedChars1 QuotedBracket1 Dollar1\n  StringQuotedPart2 StringQuotedChars2 QuotedBracket2 Dollar2\n  StringQuotedPart3 StringQuotedChars3 QuotedBracket3 Dollar3\n  StringQuotedPart4 StringQuotedChars4 QuotedBracket4 Dollar4\n  Padding\n\nsyntax\n\n  PPTerm-CF = StringQuotation\n\n  StringQuotation.StringQuotation1 = \"$\" \"[\" Padding StringQuotedPart1* \"]\"\n  StringQuotedPart1.StringEscape1  = Padding \"[\" LAYOUT?-CF Term-CF LAYOUT?-CF \"]\"\n  StringQuotedPart1.QStr           = StringQuotedChars1-LEX\n  StringQuotedPart1.QDollar        = Dollar1-LEX\n  StringQuotedPart1.QBr            = \"$\" QuotedBracket1-LEX \"$\"\n  StringQuotedChars1-LEX           = ~[\\[\\]\\$]+\n  QuotedBracket1-LEX               = [\\[\\]]\n  Dollar1-LEX                      = \"$\"\n\n  StringQuotation.StringQuotation2 = \"$\" \"{\" Padding StringQuotedPart2* \"}\"\n  StringQuotedPart2.StringEscape2  =  Padding \"{\" LAYOUT?-CF Term-CF LAYOUT?-CF \"}\"\n  StringQuotedPart2.QStr           = StringQuotedChars2-LEX\n  StringQuotedPart2.QDollar        = Dollar2-LEX\n  StringQuotedPart2.QBr            = \"$\" QuotedBracket2-LEX \"$\"\n  StringQuotedChars2-LEX           = ~[\\{\\}\\$]+\n  QuotedBracket2-LEX               = [\\{\\}]\n  Dollar2-LEX                      = \"$\"\n\n  StringQuotation.StringQuotation3 = \"$\" \"(\" Padding StringQuotedPart3* \")\"\n  StringQuotedPart3.StringEscape3  = Padding \"(\" LAYOUT?-CF Term-CF LAYOUT?-CF \")\"\n  StringQuotedPart3.QStr           = StringQuotedChars3-LEX\n  StringQuotedPart3.QDollar        = Dollar3-LEX\n  StringQuotedPart3.QBr            = \"$\" QuotedBracket3-LEX \"$\"\n  StringQuotedChars3-LEX           = ~[\\(\\)\\$]+\n  QuotedBracket3-LEX               = [\\(\\)]\n  Dollar3-LEX                      = \"$\"\n\n  StringQuotation.StringQuotation4 = \"$\" \"&lt;\" Padding StringQuotedPart4* \"&gt;\"\n  StringQuotedPart4.StringEscape4  = Padding \"&lt;\"  LAYOUT?-CF Term-CF LAYOUT?-CF \"&gt;\"\n  StringQuotedPart4.QStr           = StringQuotedChars4-LEX\n  StringQuotedPart4.QDollar        = Dollar4-LEX\n  StringQuotedPart4.QBr            = \"$\" QuotedBracket4-LEX \"$\"\n  StringQuotedChars4-LEX           = ~[\\&lt;\\&gt;\\$]+\n  QuotedBracket4-LEX               = [\\&lt;\\&gt;]\n  Dollar4-LEX                      = \"$\"\n\n  // Padding is a dummy lexical that will contain the indentation prefix of every quotation\n  Padding = Padding-LEX \n  Padding-LEX = {indentpadding}\n\nlexical restrictions\n\n  StringQuotedChars1 -/- ~[\\[\\]\\$]\n  StringQuotedChars2 -/- ~[\\{\\}\\$]\n  StringQuotedChars3 -/- ~[\\(\\)\\$]\n  StringQuotedChars4 -/- ~[\\&lt;\\&gt;\\$]\n  Dollar1 -/- [\\[\\]].[\\$]\n  Dollar2 -/- [\\{\\}].[\\$]\n  Dollar3 -/- [\\(\\)].[\\$]\n  Dollar4 -/- [\\&lt;\\&gt;].[\\$]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/terms/StringQuotations.sdf3/#modal-h2","title":"StringQuotations.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/terms/Terms.sdf3/","title":"<code>Terms.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/terms/Terms.sdf3</p> <pre><code>module terms/Terms\n\nimports \n\n  terms/Constants \n  common/Identifiers  \n  terms/Vars\n\nsorts\n\n  Pattern\n\ncontext-free syntax\n\n  Pattern = &lt;&lt;Var&gt;&gt; \n  Pattern.Int = &lt;&lt;Int&gt;&gt; \n  Pattern.Real = &lt;&lt;Real&gt;&gt; \n  Pattern.Str = &lt;&lt;String&gt;&gt; \n  Pattern.Op = &lt;&lt;Id&gt;(&lt;{Pattern \", \"}*&gt;)&gt; \n  Pattern.OpQ = &lt;&lt;String&gt;(&lt;{Pattern \", \"}*&gt;)&gt; \n  Pattern.Char = &lt;&lt;Char&gt;&gt; \n  Pattern.Tuple = &lt;(&lt;{Pattern \", \"}*&gt;)&gt; \n  Pattern.List = &lt;[&lt;{Pattern \", \"}*&gt;]&gt; \n  Pattern.ListTail = &lt;[&lt;{Pattern \", \"}*&gt; | &lt;Pattern&gt;]&gt; \n  Pattern.As = &lt;&lt;Var&gt;@&lt;Pattern&gt;&gt; \n\nsorts\n\n  Term\n\ncontext-free syntax\n\n  Term = &lt;&lt;VarRef&gt;&gt; \n  Term.Int = &lt;&lt;Int&gt;&gt; \n  Term.Real = &lt;&lt;Real&gt;&gt; \n  Term.Str = &lt;&lt;String&gt;&gt; \n  Term.Op = &lt;&lt;Id&gt;(&lt;{Term \", \"}*&gt;)&gt; \n  Term.OpQ = &lt;&lt;String&gt;(&lt;{Term \", \"}*&gt;)&gt; \n  Term.Char = &lt;&lt;Char&gt;&gt; \n  Term.Tuple = &lt;(&lt;{Term \", \"}*&gt;)&gt; \n  Term.List = &lt;[&lt;{Term \", \"}*&gt;]&gt; \n  Term.ListTail = &lt;[&lt;{Term \", \"}*&gt; | &lt;Term&gt;]&gt; \n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/terms/Terms.sdf3/#modal-h2","title":"Terms.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/syntax/terms/Vars.sdf3/","title":"<code>Vars.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/syntax/terms/Vars.sdf3</p> <pre><code>module terms/Vars\n\nimports \n\n  common/Identifiers  \n  terms/Terms\n\nsorts\n\n  Wld Var VarRef\n\ncontext-free syntax\n\n  Wld.Wld = &lt;_&gt; \n  Var = Wld \n  Var.Var = Id \n  Var.ListVar = LId \n  VarRef.VarRef = Id \n  VarRef.ListVarRef = LId \n\ncontext-free restrictions\n\n  Wld -/- [a-zA-Z0-9\\'\\-\\_]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/syntax/terms/Vars.sdf3/#modal-h2","title":"Vars.sdf3","text":""},{"location":"org.metaborg.meta.lang.nabl/trans/analysis/names.nab/","title":"<code>names.nab</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.lang.nabl/trans/analysis/names.nab</p> <pre><code>module analysis/names\n\nimports \n\n  syntax/-\n  syntax/core/-\n  syntax/terms/-\n\nnamespaces\n\n  Module\n  Namespace\n  Property\n  Variable\n\nbinding rules\n\n  Module(m, _): \n    defines Module m\n    scopes Namespace, Property\n\n  Import(m): \n    imports Namespace, Property from Module m\n\nbinding rules\n\n  NamespaceDef(n): \n    defines non-unique Namespace n\n\n  NamespaceRef(CurrentLanguage(), n): \n    refers to Namespace n\n\nbinding rules\n\n  PropertyDef(p, ns, t): \n    defines non-unique Property p of type (ns, t)\n\n  PropertyRef(p): \n    refers to Property p\n\nbinding rules\n\n  BindingRule(_, _, _):\n    scopes Variable\n\n  RefClausePart(_, _, _, _, _, _):\n    scopes Variable\n\n  WildcardImport(_, _, _, _, _):\n    scopes Variable\n\n  SingleImport(_, _, _, _, _, _, _, _):\n    scopes Variable\n\n  Var(x):\n    defines Variable x\n\n  ListVar(x):\n    defines Variable x\n\n  VarRef(x):\n    refers to Variable x\n\n  ListVarRef(x):\n    refers to Variable x\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.lang.nabl/trans/analysis/names.nab/#modal-h2","title":"names.nab","text":""},{"location":"org.metaborg.meta.nabl2.lang/","title":"NaBL2","text":"<p>The NaBL2 'Name Binding Language' supports the specification of name binding and type checking rules of a language.</p> <p>NaBL2 uses a constraint-based approach, and uses scope graphs for name resolution.</p> <p>The NaBL2 documentation explains the details.</p> <p>NaBL2 is now deprecated. It has been superseded by Statix.</p> <p>However, NaBL2 is still used in Spoofax 2 for specifying the name binding of several meta-languages (e.g., Statix).</p>"},{"location":"org.metaborg.meta.nabl2.lang/#syntax","title":"Syntax","text":"<p><code>syntax/NaBL2Lang.sdf3</code></p> <p>The syntax of NaBL2 is specified in SDF3.</p>"},{"location":"org.metaborg.meta.nabl2.lang/#name-binding","title":"Name binding","text":"<p>The name binding of NaBL2 definitions has not been specified, so browsing them is not supported by hyperlinked twins.</p>"},{"location":"org.metaborg.meta.nabl2.lang/src-gen/syntax/permissive-water.sdf3/","title":"<code>permissive-water.sdf3</code>","text":"<pre><code>module permissive-water\n\n// Key idea: WATER is the inverse of LAYOUT\n\ncontext-free syntax\n  // Allow WATER on places where LAYOUT may occur\n  LAYOUT.WATER = WATER\n\nlexical sorts\n  WATER\n  WATERTOKEN\n  WATERTOKENSTART\n  WATERTOKENSEPARATOR\n\nlexical syntax\n  // Separate water regions into smaller chunks for recovery costs calculation\n  WATER = WATERTOKEN\n  WATER = WATERTOKENSEPARATOR\n\n  // Allow to skip over identifier strings\n  WATERTOKEN      = WATERTOKENSTART [A-Za-z0-9\\_]*\n  WATERTOKENSTART = [A-Za-z0-9\\_] {recover}\n\n  // Allow to skip over special characters that are neither part of identifiers nor whitespace characters\n  WATERTOKENSEPARATOR = ~[A-Za-z0-9\\_\\ \\t\\12\\r\\n\\*] {recover}\n\nlexical restrictions\n  WATERTOKEN -/- [A-Za-z0-9\\_]\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/src-gen/syntax/permissive-water.sdf3/#modal-h2","title":"permissive-water.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/Layout.sdf3/","title":"<code>Layout.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/Layout.sdf3</p> <pre><code>module Layout\n\nlexical syntax\n\n  LAYOUT = [\\t\\ \\r\\n]\n  LAYOUT = LineComment\n  LAYOUT = BlockComment\n\n  EOF =  \n\n  LineComment     = \"//\" ~[\\r\\n]* ([\\r\\n] | EOF)\n\n  BlockComment    = \"/*\" CommentText (BlockComment CommentText)* (\"*/\" | EOF)\n  CommentText     = CommentChar*\n  CommentChar     = ~[\\*\\/] | CommentAsterisk | CommentSlash\n  CommentSlash    = \"/\"\n  CommentAsterisk = \"*\"\n\nlexical restrictions\n\n  EOF             -/- ~[]\n  CommentText     -/- ~[\\*\\/]\n  CommentAsterisk -/- [\\/]\n  CommentSlash    -/- [\\*]\n\ncontext-free restrictions\n\n  LAYOUT? -/- [\\ \\t\\r\\n]   // whitespace\n  LAYOUT? -/- [\\/].[\\/]    // line comment start\n  LAYOUT? -/- [\\/].[\\*]    // block comment start\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/Layout.sdf3/#modal-h2","title":"Layout.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/NaBL2Lang.sdf3/","title":"<code>NaBL2Lang.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/NaBL2Lang.sdf3</p> <pre><code>module NaBL2Lang\n\nimports\n\n  nabl2/Lang\n  nabl2/lang/modules/Module // not transitively visible\n  Layout\n\ncontext-free start-symbols\n\n  NaBL2-Module\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/NaBL2Lang.sdf3/#modal-h2","title":"NaBL2Lang.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/Lang.sdf3/","title":"<code>Lang.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/Lang.sdf3</p> <pre><code>module nabl2/Lang\n\nimports\n\n  nabl2/Shared\n  nabl2/lang/Main\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/Lang.sdf3/#modal-h2","title":"Lang.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/Main.sdf3/","title":"<code>Main.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/Main.sdf3</p> <pre><code>module nabl2/lang/Main\n\nimports\n\n  nabl2/lang/common/Main\n  nabl2/lang/modules/Module\n  nabl2/lang/rules/Rules\n  nabl2/lang/signatures/Signature\n\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/Main.sdf3/#modal-h2","title":"Main.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/CTerms.sdf3/","title":"<code>CTerms.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/CTerms.sdf3</p> <pre><code>module nabl2/lang/common/CTerms\n\nimports\n\n  nabl2/shared/common/CTerms\n  nabl2/shared/common/Identifiers\n  nabl2/shared/common/ScopeGraph\n  nabl2/shared/common/Sets\n  nabl2/shared/constraints/Base\n  nabl2/lang/common/Terms\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\'\\_]\n\ncontext-free syntax\n\n  NaBL2-CVar.Var = NaBL2-VarId\n  NaBL2-CVar.Wld = &lt;_&gt;\n\nsyntax\n\n  NaBL2-CTerm-CF.Op    = NaBL2-OpId-LEX \"(\" LAYOUT?-CF NaBL2-CTerms-CF LAYOUT?-CF \")\"\n\ncontext-free syntax\n\n  NaBL2-CTerm.Tuple = &lt;(&lt;{NaBL2-CTerm \", \"}*&gt;)&gt;\n\n  NaBL2-CTerm       = NaBL2-IntTerm\n  NaBL2-CTerm       = NaBL2-StringTerm\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/CTerms.sdf3/#modal-h2","title":"CTerms.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Identifiers.sdf3/","title":"<code>Identifiers.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Identifiers.sdf3</p> <pre><code>module nabl2/lang/common/Identifiers\n\nimports\n\n  nabl2/shared/common/Identifiers\n\nlexical syntax\n\n  NaBL2-RuleId = [a-zA-Z] [a-zA-Z0-9]*\n  NaBL2-RuleId = \"init\" | \"default\" {case-insensitive, reject}\n\nlexical restrictions\n\n  NaBL2-RuleId -/- [a-zA-Z0-9]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Identifiers.sdf3/#modal-h2","title":"Identifiers.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Injections.sdf3/","title":"<code>Injections.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Injections.sdf3</p> <pre><code>module nabl2/lang/common/Injections\n\nimports\n\n  nabl2/shared/common/CTerms\n  nabl2/shared/common/Identifiers\n  nabl2/shared/common/Resolution\n  nabl2/shared/common/ScopeGraph\n  nabl2/shared/common/Sets\n  nabl2/shared/constraints/Base\n  nabl2/lang/common/Terms\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\'\\_]\n\ncontext-free syntax\n\n  NaBL2-Message.DefaultMessage =\n\n  NaBL2-MessagePosition.DefaultMessagePosition =\n  NaBL2-MessagePosition.MessagePositionFrom    = &lt; @ &lt;NaBL2-Var&gt;&gt;\n\n  NaBL2-OccurrenceIndex.DefaultOccurrenceIndex =\n  NaBL2-OccurrenceIndex.OccurrenceIndexFrom    = &lt; @ &lt;NaBL2-Var&gt;&gt;\n\n  NaBL2-LabelRE.Option    = &lt;&lt;NaBL2-LabelRE&gt;?&gt;\n  NaBL2-LabelRE.ConcatDot = &lt;&lt;NaBL2-LabelRE&gt;.&lt;NaBL2-LabelRE&gt;&gt;  {right,deprecated(\"The dot for concatenation is unnecessary, and can be omitted.\")}\n  NaBL2-LabelRE.NonEmpty = &lt;&lt;NaBL2-LabelRE&gt;+&gt;\n\n  NaBL2-ELabel.DefaultELabel = \"-\"\n  NaBL2-NLabel.DefaultNLabel = \"=\"\n\n  NaBL2-Constraint.CDeclType = [[NaBL2-Occurrence] : [NaBL2-CTerm] [NaBL2-ConstraintPriority] [NaBL2-Message]]\n\n  NaBL2-Constraint.CGen  = [[NaBL2-CTerm] genOf [NaBL2-CTerm] [NaBL2-Message]]\n  NaBL2-Constraint.CInst = [[NaBL2-CTerm] instOf [NaBL2-CTerm] [NaBL2-Message]]\n\nsyntax\n\n  NaBL2-TermIndex-CF.TermIndexFrom = \"@\" NaBL2-Var-CF\n\n  NaBL2-Constraint-CF.CSetEq = NaBL2-CSet-CF LAYOUT?-CF \"seteq\" NaBL2-SetProj-CF LAYOUT?-CF NaBL2-CSet-CF LAYOUT?-CF NaBL2-Message-CF\n\ncontext-free priorities\n\n    { NaBL2-LabelRE.Closure NaBL2-LabelRE.Option NaBL2-LabelRE.NonEmpty }\n  &gt; { right: NaBL2-LabelRE.Concat NaBL2-LabelRE.ConcatDot }\n  &gt; NaBL2-LabelRE.And\n  &gt; NaBL2-LabelRE.Or\n\nlexical syntax\n\n  NaBL2-Keyword = \"seteq\" | \"genOf\" | \"instOf\" | \"new\" | \"this\"\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Injections.sdf3/#modal-h2","title":"Injections.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Main.sdf3/","title":"<code>Main.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Main.sdf3</p> <pre><code>module nabl2/lang/common/Main\n\nimports\n\n  nabl2/lang/common/CTerms\n  nabl2/lang/common/Identifiers\n  nabl2/lang/common/Injections\n  nabl2/lang/common/Messages\n  nabl2/lang/common/Terms\n\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Main.sdf3/#modal-h2","title":"Main.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Messages.sdf3/","title":"<code>Messages.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Messages.sdf3</p> <pre><code>module nabl2/lang/common/Messages\n\nimports\n\n  nabl2/shared/common/CTerms\n  nabl2/lang/common/Terms\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\'\\_]\n\nsyntax\n\n  NaBL2-MessageContent-CF.Formatted = \"$[\" NaBL2-MessageContentPart-CF* \"]\"\n\ncontext-free syntax\n\n  NaBL2-MessageContent.Default  =\n  NaBL2-MessageContent          = NaBL2-StringTerm\n\n  NaBL2-MessageContentPart.Term = &lt;[&lt;NaBL2-CTerm&gt;]&gt;\n  NaBL2-MessageContentPart.Text = NaBL2-MessageChars\n\nlexical syntax\n\n  NaBL2-MessageChars = NaBL2-MessageChar+\n  NaBL2-MessageChar  = ~[\\[\\]\\\\\\t\\r\\n]\n  NaBL2-MessageChar  = \"\\\\[\" | \"\\\\]\" | \"\\\\\\\\\"\n\nlexical restrictions\n\n  NaBL2-MessageChars -/- ~[\\[\\]]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Messages.sdf3/#modal-h2","title":"Messages.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Terms.sdf3/","title":"<code>Terms.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Terms.sdf3</p> <pre><code>module nabl2/lang/common/Terms\n\nimports\n\n  nabl2/shared/common/Identifiers\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\']\n\ncontext-free syntax\n\n  NaBL2-Var.Var   = NaBL2-VarId\n  NaBL2-Wld.Wld   = \"_\"\n\n  NaBL2-VarOrWld  = NaBL2-Var\n  NaBL2-VarOrWld  = NaBL2-Wld\n\n  NaBL2-Pattern          = NaBL2-VarOrWld\n  NaBL2-Pattern.List     = &lt;[&lt;{NaBL2-Pattern \", \"}*&gt;]&gt;\n  NaBL2-Pattern.ListTail = &lt;[&lt;{NaBL2-Pattern \", \"}*&gt;|&lt;NaBL2-Pattern&gt;]&gt;\n  NaBL2-Pattern.Tuple    = &lt;(&lt;{NaBL2-Pattern \", \"}*&gt;)&gt;\n  NaBL2-Pattern.As       = &lt;&lt;NaBL2-Var&gt;@&lt;NaBL2-Pattern&gt;&gt;\n  NaBL2-Pattern          = NaBL2-OpTerm\n  NaBL2-Pattern          = NaBL2-IntTerm\n  NaBL2-Pattern          = NaBL2-StringTerm\n\n  NaBL2-Patterns         = &lt;&lt;{NaBL2-Pattern \", \"}*&gt;&gt;\n\ncontext-free syntax\n\n  NaBL2-IntTerm.Int = NaBL2-INT\n\nsyntax\n\n  NaBL2-OpTerm-CF.Op      = NaBL2-OpId-LEX \"(\" LAYOUT?-CF NaBL2-Patterns-CF LAYOUT?-CF  \")\"\n\n  NaBL2-StringTerm-CF.Str = \"\\\"\" NaBL2-StringChars-LEX \"\\\"\"\n\nlexical syntax\n\n  NaBL2-StringChars   = NaBL2-StringChar*\n  NaBL2-StringChar    = ~[\\\"\\\\\\t\\r\\n]\n  NaBL2-StringChar    =  \"\\\\\\\"\" | \"\\\\\\\\\" | \"\\\\t\" | \"\\\\r\" | \"\\\\n\"\n\nlexical restrictions\n\n  NaBL2-StringChars -/- ~[\\\"]\n\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/common/Terms.sdf3/#modal-h2","title":"Terms.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/modules/Module.sdf3/","title":"<code>Module.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/modules/Module.sdf3</p> <pre><code>module nabl2/lang/modules/Module\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\.\\-\\_]\n\ncontext-free syntax\n\n  NaBL2-Module.Module = &lt;\n    module &lt;NaBL2-ModuleId&gt;\n\n    &lt;{NaBL2-ModuleSection \"\\n\"}*&gt;\n  &gt;\n\n  NaBL2-ModuleSection.Imports = &lt;\n    imports &lt;NaBL2-ImportModule*&gt;\n  &gt;\n\n  NaBL2-ImportModule.Import = &lt;&lt;NaBL2-ModuleId&gt;&gt; \n\nsyntax\n\n  NaBL2-ImportModule-CF.ImportWildcard = NaBL2-ModuleId-CF \"/-\"\n\nlexical syntax\n\n  NaBL2-ModuleId = {NaBL2-ModuleIdPart \"/\"}+\n  NaBL2-ModuleIdPart = [a-zA-Z\\_] [a-zA-Z0-9\\.\\-\\_]*\n  NaBL2-ModuleId = NaBL2-SectionKeyword {reject}\n\n  NaBL2-RuleId = NaBL2-SectionKeyword {reject}\n\n  NaBL2-SectionKeyword = \"imports\"\n\nlexical restrictions\n\n  NaBL2-ModuleId -/- [a-zA-Z0-9\\.\\-\\_]\n\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/modules/Module.sdf3/#modal-h2","title":"Module.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/rules/CGen.sdf3/","title":"<code>CGen.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/rules/CGen.sdf3</p> <pre><code>module nabl2/lang/rules/CGen\n\nimports\n\n  nabl2/shared/common/CTerms\n  nabl2/shared/common/Identifiers\n  nabl2/shared/constraints/Base\n\n  nabl2/lang/common/Identifiers\n  nabl2/lang/common/Injections\n  nabl2/lang/common/Terms\n  nabl2/lang/rules/Rules\n  nabl2/lang/rules/Names\n\n\ncontext-free syntax\n\n  NaBL2-Rule.CGenInitRuleNoConstraint = &lt;\n    init &lt;NaBL2-CGenParamsTerm&gt; &lt;NaBL2-CGenTypeTerm&gt;.\n  &gt;\n\n  NaBL2-Rule.CGenInitRule = &lt;\n    init &lt;NaBL2-CGenParamsTerm&gt; &lt;NaBL2-CGenTypeTerm&gt; :=\n        &lt;NaBL2-RuleBody&gt;.\n  &gt;\n\n  NaBL2-Rule.CGenRuleNoConstraint = &lt;\n    &lt;NaBL2-CGenRuleDef&gt; [[ &lt;NaBL2-Pattern&gt; &lt;NaBL2-CGenParamsPattern&gt; &lt;NaBL2-CGenTypePattern&gt; ]] .\n  &gt;\n\n  NaBL2-Rule.CGenRule = &lt;\n    &lt;NaBL2-CGenRuleDef&gt; [[ &lt;NaBL2-Pattern&gt; &lt;NaBL2-CGenParamsPattern&gt; &lt;NaBL2-CGenTypePattern&gt; ]] :=\n        &lt;NaBL2-RuleBody&gt;.\n  &gt;\n\n  NaBL2-RuleBody       = NaBL2-Constraint\n\n  NaBL2-Constraint.CGenRecurse = &lt;&lt;NaBL2-CGenRuleRefTop&gt;[[ &lt;NaBL2-Var&gt; &lt;NaBL2-CGenParamsTerm&gt; &lt;NaBL2-CGenTypeTerm&gt; ]]&gt;\n\n\ncontext-free syntax\n\n  NaBL2-CGenParamsTerm          =                             {ast(\"Tuple([])\")}\n  NaBL2-CGenParamsTerm.Tuple    = &lt;^ (&lt;{NaBL2-CTerm \", \"}*&gt;)&gt;\n\n  NaBL2-CGenParamsPattern       =                                {ast(\"Tuple([])\")}\n  NaBL2-CGenParamsPattern.Tuple = &lt;^ (&lt;{NaBL2-VarOrWld \", \"}*&gt;)&gt;\n\n  NaBL2-CGenTypeTerm.NoType     =\n  NaBL2-CGenTypeTerm.Type       = &lt;: &lt;NaBL2-CTerm&gt;&gt;\n\n  NaBL2-CGenTypePattern.NoType  =\n  NaBL2-CGenTypePattern.Type    = &lt;: &lt;NaBL2-CTerm&gt;&gt;\n\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/rules/CGen.sdf3/#modal-h2","title":"CGen.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/rules/Names.sdf3/","title":"<code>Names.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/rules/Names.sdf3</p> <pre><code>module nabl2/lang/rules/Names\n\nimports\n\n  nabl2/shared/common/Identifiers\n  nabl2/lang/common/Identifiers\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\']\n\nsyntax\n\n  NaBL2-CGenRuleDef-CF.DefaultRule     =\n  NaBL2-CGenRuleDef-CF.InitRule   = \"init\"\n  NaBL2-CGenRuleDef-CF.RuleNoArgs = NaBL2-RuleId-LEX\n  NaBL2-CGenRuleDef-CF.Rule       = NaBL2-RuleId-LEX \"(\" LAYOUT?-CF NaBL2-RuleIds-CF LAYOUT?-CF \")\"\n\n\n  NaBL2-CGenRuleRefTop-CF.DefaultRule     =\n  NaBL2-CGenRuleRefTop-CF.RuleNoArgs = NaBL2-RuleId-LEX\n  NaBL2-CGenRuleRefTop-CF.Rule       = NaBL2-RuleId-LEX \"(\" LAYOUT?-CF NaBL2-CGenRuleRefs-CF LAYOUT?-CF \")\"\n\n  NaBL2-CGenRuleRef-CF.DefaultRule     = \"default\"\n  NaBL2-CGenRuleRef-CF.RuleNoArgs = NaBL2-RuleId-LEX\n  NaBL2-CGenRuleRef-CF.Rule       = NaBL2-RuleId-LEX \"(\" LAYOUT?-CF NaBL2-CGenRuleRefs-CF LAYOUT?-CF \")\"\n\ncontext-free syntax\n\n  NaBL2-RuleIds = &lt;&lt;{NaBL2-RuleId \", \"}*&gt;&gt;\n\n  NaBL2-CGenRuleRefs = &lt;&lt;{NaBL2-CGenRuleRef \", \"}*&gt;&gt;\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/rules/Names.sdf3/#modal-h2","title":"Names.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/rules/Rules.sdf3/","title":"<code>Rules.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/rules/Rules.sdf3</p> <pre><code>module nabl2/lang/rules/Rules\n\nimports\n\n  nabl2/lang/rules/CGen\n  nabl2/lang/rules/Names\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\']\n\ncontext-free syntax\n\n  NaBL2-ModuleSection.Rules = &lt;\n    rules\n\n      &lt;{NaBL2-Rule \"\\n\\n\"}*&gt;\n\n  &gt; {longest-match}\n\nlexical syntax\n\n  NaBL2-SectionKeyword = \"rules\"\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/rules/Rules.sdf3/#modal-h2","title":"Rules.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/CGen.sdf3/","title":"<code>CGen.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/CGen.sdf3</p> <pre><code>module nabl2/lang/signatures/CGen\n\nimports\n\n  nabl2/shared/common/Sorts\n  nabl2/lang/rules/Names\n  nabl2/lang/rules/CGen\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\']\n\ncontext-free syntax\n\n  NaBL2-Signature.CGen = &lt;\n    constraint generator\n      &lt;{NaBL2-CGenSig \"\\n\"}*&gt;\n\n  &gt;\n\n  NaBL2-CGenSig.CGenInitSig = &lt;init &lt;NaBL2-CGenSigParams&gt; &lt;NaBL2-CGenSigType&gt;&gt;\n  NaBL2-CGenSig.CGenSig     = &lt;&lt;NaBL2-CGenRuleDef&gt; [[ &lt;NaBL2-SortRef&gt; &lt;NaBL2-CGenSigParams&gt; &lt;NaBL2-CGenSigType&gt; ]]&gt;\n\n  NaBL2-CGenSigParams   =                               {ast(\"[]\")}\n  NaBL2-CGenSigParams   = &lt;^ (&lt;{NaBL2-SortRef \", \"}*&gt;)&gt;\n\n  NaBL2-CGenSigType.NoType = &lt;&gt;\n  NaBL2-CGenSigType.Type   = &lt;: &lt;NaBL2-SortRef&gt;&gt;\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/CGen.sdf3/#modal-h2","title":"CGen.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/Constructors.sdf3/","title":"<code>Constructors.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/Constructors.sdf3</p> <pre><code>module nabl2/lang/signatures/Constructors\n\nimports\n\n  nabl2/shared/common/Identifiers\n  nabl2/shared/common/Sorts\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\']\n\ncontext-free syntax\n\n  NaBL2-Signature.Sorts = &lt;\n    sorts\n      &lt;{NaBL2-Sort \"\\n\"}*&gt;\n  &gt; {longest-match}\n\n  NaBL2-Signature.Constructors = &lt;\n    constructors\n      &lt;{NaBL2-OpDecl \"\\n\"}*&gt;\n  &gt; {longest-match}\n\n  NaBL2-OpDecl.OpDecl        = [[NaBL2-OpId] : [{NaBL2-SortRef \" * \"}*] -&gt; [NaBL2-Sort]]\n  NaBL2-OpDecl.NullaryOpDecl = [[NaBL2-OpId] : [NaBL2-Sort]]\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/Constructors.sdf3/#modal-h2","title":"Constructors.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/Functions.sdf3/","title":"<code>Functions.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/Functions.sdf3</p> <pre><code>module nabl2/lang/signatures/Functions\n\nimports\n\n  nabl2/shared/common/Identifiers\n  nabl2/shared/common/Functions\n  nabl2/shared/common/Sorts\n  nabl2/lang/common/CTerms\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\']\n\ncontext-free syntax\n\n  NaBL2-Signature.Functions = &lt;\n    functions\n      &lt;{NaBL2-FunctionDef \"\\n\\n\"}*&gt;\n  &gt; {longest-match}\n\ncontext-free syntax\n\n  NaBL2-FunctionDef.FunctionDef = &lt;&lt;NaBL2-Function&gt; &lt;NaBL2-FunctionType&gt; &lt;NaBL2-FunctionCases&gt;&gt;\n\n  NaBL2-FunctionType  = [: [NaBL2-SortRef] -&gt; [NaBL2-SortRef]]\n\n  NaBL2-FunctionCases = &lt;\n    { &lt;{NaBL2-FunctionCase \",\\n\"}*&gt;\n    }\n  &gt;\n  NaBL2-FunctionCases = {ast(\"[]\")}\n\n  NaBL2-FunctionCase  = [[NaBL2-CTerm] -&gt; [NaBL2-CTerm]]\n\nlexical syntax\n\n  NaBL2-SectionKeyword = \"functions\"\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/Functions.sdf3/#modal-h2","title":"Functions.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/NameResolution.sdf3/","title":"<code>NameResolution.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/NameResolution.sdf3</p> <pre><code>module nabl2/lang/signatures/NameResolution\n\nimports\n\n  nabl2/shared/common/Identifiers\n  nabl2/shared/common/ScopeGraph\n  nabl2/shared/common/Sorts\n  nabl2/shared/common/Resolution\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\']\n\ncontext-free syntax\n\n  NaBL2-Signature.NameResolution = &lt;\n    name resolution\n      &lt;{NaBL2-NameResolutionParam \"\\n\\n\"}*&gt;\n  &gt; {longest-match}\n\n  NaBL2-NameResolutionParam.Labels        = &lt;labels &lt;{NaBL2-PathLabel \" \"}*&gt;&gt;\n  NaBL2-NameResolutionParam.Order         = &lt;order &lt;{NaBL2-LabelOrder \",\\n\"}*&gt;&gt;\n  NaBL2-NameResolutionParam.WF            = &lt;well-formedness &lt;NaBL2-LabelRE&gt;&gt;\n  NaBL2-NameResolutionParam.DefaultELabel = &lt;default edge label &lt;NaBL2-PathLabel&gt;&gt;\n  NaBL2-NameResolutionParam.DefaultNLabel = &lt;default named label &lt;NaBL2-PathLabel&gt;&gt;\n  NaBL2-NameResolutionParam.Strategy      = &lt;strategy &lt;NaBL2-Strategy&gt;&gt;\n  NaBL2-NameResolutionParam.PathRelevance = &lt;paths &lt;NaBL2-Relevance&gt;&gt;\n\ncontext-free syntax\n\n  NaBL2-Signature.Namespaces = &lt;\n    namespaces\n      &lt;{NaBL2-NamespaceDef \"\\n\\n\"}*&gt;\n  &gt; {longest-match}\n\n  NaBL2-NamespaceDef.NamespaceDef = &lt;&lt;NaBL2-Namespace&gt; &lt;NaBL2-NamespaceType&gt; &lt;NaBL2-NamespaceProperties&gt;&gt;\n\n  NaBL2-NamespaceType.NoType  =\n  NaBL2-NamespaceType.Type    = &lt;: &lt;NaBL2-SortRef&gt;&gt;\n\n  NaBL2-NamespaceProperties = &lt;{ &lt;{NaBL2-NamespaceProperty \",\\n\"}*&gt; }&gt;\n  NaBL2-NamespaceProperties = {ast(\"[]\")}\n\n  NaBL2-NamespaceProperty.PropertyDef = &lt;&lt;NaBL2-PropertyId&gt; : &lt;NaBL2-SortRef&gt;&gt;\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/NameResolution.sdf3/#modal-h2","title":"NameResolution.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/Relations.sdf3/","title":"<code>Relations.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/Relations.sdf3</p> <pre><code>module nabl2/lang/signatures/Relations\n\nimports\n\n  nabl2/shared/common/Identifiers\n  nabl2/shared/common/Relations\n  nabl2/shared/common/Sorts\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\']\n\ncontext-free syntax\n\n  NaBL2-Signature.Relations = &lt;\n    relations\n      &lt;{NaBL2-RelationDef \"\\n\\n\"}*&gt;\n  &gt; {longest-match}\n\ncontext-free syntax\n\n  NaBL2-RelationDef.RelationDef = &lt;&lt;{NaBL2-RelationOption \", \"}*&gt; &lt;NaBL2-Relation&gt; &lt;NaBL2-RelationType&gt; &lt;NaBL2-VariancePatterns&gt;&gt;\n\n  NaBL2-RelationOption = NaBL2-Reflexivity\n  NaBL2-RelationOption = NaBL2-Symmetry\n  NaBL2-RelationOption = NaBL2-Transitivity\n\n  NaBL2-RelationType = &lt;: &lt;NaBL2-SortRef&gt; * &lt;NaBL2-SortRef&gt;&gt;\n\n  NaBL2-VariancePatterns      = &lt;{ &lt;{NaBL2-VariancePattern \",\\n\"}*&gt; }&gt;\n  NaBL2-VariancePatterns      = {ast(\"[]\")}\n\n lexical syntax\n\n  NaBL2-Keyword = \"relations\"\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/Relations.sdf3/#modal-h2","title":"Relations.sdf3","text":""},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/Signature.sdf3/","title":"<code>Signature.sdf3</code>","text":"<p> pdmosses/nabl/org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/Signature.sdf3</p> <pre><code>module nabl2/lang/signatures/Signature\n\nimports\n\n  nabl2/lang/signatures/CGen\n  nabl2/lang/signatures/Constructors\n  nabl2/lang/signatures/Functions\n  nabl2/lang/signatures/NameResolution\n  nabl2/lang/signatures/Relations\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\']\n\ncontext-free syntax\n\n  NaBL2-ModuleSection.Signature = &lt;\n    signature\n      &lt;{NaBL2-Signature \"\\n\\n\"}*&gt;\n  &gt;\n\nlexical syntax\n\n  NaBL2-SectionKeyword = \"signature\"\n\n\n</code></pre> \u00d7"},{"location":"org.metaborg.meta.nabl2.lang/syntax/nabl2/lang/signatures/Signature.sdf3/#modal-h2","title":"Signature.sdf3","text":""},{"location":"statix.example/","title":"Statix examples","text":""},{"location":"statix.example/#tests","title":"Tests","text":"<p>This project includes some basic examples and tests of Statix.</p>"},{"location":"statix.example/#language-specifications","title":"Language specifications","text":"<p>Examples of complete Statix specifications are provided elsewhere, including:</p> <ul> <li>the Tiger pedagogical programming language</li> <li>the WebDSL domain-specific language for web applications</li> </ul>"},{"location":"statix.example/src/busybeaver.stxtest/","title":"<code>busybeaver.stxtest</code>","text":"<p> pdmosses/nabl/statix.example/src/busybeaver.stxtest</p> <pre><code>// 3-state Busy Beaver Turing machine specification\n// https://en.wikipedia.org/wiki/Turing_machine_examples#3-state_Busy_Beaver\n\nresolve\n\n  busybeaver(A(), ([], Zero(), []))\n\nsignature\n\n  sorts State constructors\n    A    : State\n    B    : State\n    C    : State\n    HALT : State\n\n  sorts Symbol constructors\n    Zero : Symbol\n    One  : Symbol\n\n  sorts Move constructors\n    R : Move\n    L : Move\n    N : Move\n\n  sorts Tape = (list(Symbol) * Symbol * list(Symbol))\n\nrules\n\n  busybeaver : State * Tape\n\n  busybeaver(A(), (left, Zero(), right)) :-\n    busybeaver(B(), move((left, One(), right), R())).\n\n  busybeaver(A(), (left, One(), right)) :-\n    busybeaver(C(), move((left, One(), right), L())).\n\n  busybeaver(B(), (left, Zero(), right)) :-\n    busybeaver(A(), move((left, One(), right), L())).\n\n  busybeaver(B(), (left, One(), right)) :-\n    busybeaver(B(), move((left, One(), right), L())).\n\n  busybeaver(C(), (left, Zero(), right)) :-\n    busybeaver(B(), move((left, One(), right), L())).\n\n  busybeaver(C(), (left, One(), right)) :-\n    busybeaver(HALT(), move((left, One(), right), R())).\n\n  busybeaver(HALT(), (left, s, right)).\n\nrules\n\n  move : Tape * Move -&gt; Tape\n\n  move((left, s, [s'|right]), R()) = ([s|left], s', right).\n\n  move((left, s, []), R()) = ([s|left], Zero(), []).\n\n  move(([s'|left], s, right), L()) = (left, s', [s|right]).\n\n  move(([], s, right), L()) = ([], Zero(), [s|right]).\n\n  move(T, N()) = T.\n\n</code></pre> \u00d7"},{"location":"statix.example/src/busybeaver.stxtest/#modal-h2","title":"busybeaver.stxtest","text":""},{"location":"statix.example/src/concat.stx/","title":"<code>concat.stx</code>","text":"<p> pdmosses/nabl/statix.example/src/concat.stx</p> <pre><code>module concat\n\nsignature\n  constraints\n    concatF : list(string) * list(string) -&gt; list(string)\n\nrules\n\n  concatF([], ys) = ys.\n  concatF([x|xs], ys) = [x|concatF(xs, ys)].\n\nsignature\n  constraints\n    concatP : list(string) * list(string) * list(string)\n\nrules\n\n  concatP([], ys, ys).\n  concatP([x|xs], ys, [x|zs]) :- concatP(xs, ys, zs).\n\n</code></pre> \u00d7"},{"location":"statix.example/src/concat.stx/#modal-h2","title":"concat.stx","text":""},{"location":"statix.example/src/concat.stxtest/","title":"<code>concat.stxtest</code>","text":"<p> pdmosses/nabl/statix.example/src/concat.stxtest</p> <pre><code>resolve {l}\n\n  concat([\"I'm\", \"afraid\", \"I\"], [\"cannot\", \"do\", \"that\", \"Dave\"]) == l\n\nsignature\n  constraints\n    concat : list(string) * list(string) -&gt; list(string)\n\nrules\n\n  concat([], ys) = zs :- ys == zs.\n  concat([x|xs], ys) = [x|concat(xs, ys)].\n\n</code></pre> \u00d7"},{"location":"statix.example/src/concat.stxtest/#modal-h2","title":"concat.stxtest","text":""},{"location":"statix.example/src/partial-classes.stxtest/","title":"<code>partial-classes.stxtest</code>","text":"<p> pdmosses/nabl/statix.example/src/partial-classes.stxtest</p> <pre><code>resolve {}\n\n  programOk([\n    PartialClass(\"A\", [\n      Field(\"x\", Var(\"y\"))\n    ]),\n    PartialClass(\"A\", [\n      Field(\"y\", Var(\"x\"))\n    ])\n  ])\n\nsignature\n\n  sorts ID = string\n\n  sorts Class constructors\n    PartialClass : ID * list(Member) -&gt; Class\n\n  sorts Member constructors\n    Field : ID * Exp -&gt; Member\n\n  sorts Exp constructors\n    Var : ID -&gt; Exp\n\n  relations\n    var: string\n    class : string -&gt; scope\n\n  name-resolution\n    labels P E\n\nrules\n\n  programOk : list(Class)\n\n  programOk(classes) :-\n    classesOk(new, classes).\n\nrules\n\n  classesOk maps classOk(*, list(*))\n  classOk : scope * Class\n\n  classOk(s, PartialClass(x, members)) :- {s' pcs}\n    new s', s' -P-&gt; s,\n    !class[x, s'] in s,\n    query class\n      filter P*\n        and { x' :- x' == x }\n      min $ &lt; P\n      in s |-&gt; pcs,\n    importPartials(pcs, s'),\n    membersOk(s', members).\n\nrules\n\n  importPartials maps importPartial(list(*), *)\n  importPartial : (path * (string * scope)) * scope\n\n  importPartial((_, (_, s)), s).\n\n  importPartial((_, (_, s')), s) :-\n    s -E-&gt; s'.\n\nrules\n\n  membersOk maps memberOk(*, list(*))\n  memberOk : scope * Member\n\n  memberOk(s, Field(x,e )) :-\n    !var[x] in s,\n    expOk(s, e).\n\nrules\n\n  expOk : scope * Exp\n\n  expOk(s, Var(x)) :-\n    query var\n      filter P* E?\n        and { x' :- x' == x }\n      min$ &lt; P, $ &lt; E, E &lt; P\n        and true\n      in s |-&gt; [_].\n\n</code></pre> \u00d7"},{"location":"statix.example/src/partial-classes.stxtest/#modal-h2","title":"partial-classes.stxtest","text":""},{"location":"statix.example/src/path-lib.stx/","title":"<code>path-lib.stx</code>","text":"<p> pdmosses/nabl/statix.example/src/path-lib.stx</p> <pre><code>module path-lib\n\nrules\n\n  src : path -&gt; scope\n  src(_PathEmpty(s)) = s.\n  src(_PathStep(p, _, _)) = src(p).\n\nrules\n\n  dst : path -&gt; scope\n  dst(_PathEmpty(s)) = s.\n  dst(_PathStep(_, _, s)) = s.\n\nrules\n\n  scopes : path -&gt; list(scope)\n  scopes(p) = scopes_acc(p, []).\n\n  scopes_acc : path * list(scope) -&gt; list(scope)\n  scopes_acc(_PathEmpty(s), acc) = [s|acc].\n  scopes_acc(_PathStep(p, _, s), acc) = scopes_acc(p, [s|acc]).\n\nrules\n\n  pathLabels : path -&gt; list(label)\n  pathLabels(p) = pathLabels_acc(p, []).\n\n  pathLabels_acc : path * list(label) -&gt; list(label)\n  pathLabels_acc(_PathEmpty(_), acc) = [].\n  pathLabels_acc(_PathStep(p, l, _), acc) = pathLabels_acc(p, [l|acc]).\n\n</code></pre> \u00d7"},{"location":"statix.example/src/path-lib.stx/#modal-h2","title":"path-lib.stx","text":""},{"location":"statix.example/src/stlc.stx/","title":"<code>stlc.stx</code>","text":"<p> pdmosses/nabl/statix.example/src/stlc.stx</p> <pre><code>module stlc // Static semantics of Simply Typed Lambda Calculus\n\nsignature\n  sorts ID = string                         // $x$\n  sorts BinOp                               // $op$\n\n  sorts Exp constructors                    // $e$ :=\n    Num     : ID -&gt; Exp                     //      | $n$\n    BinExp  : Exp * BinOp * Exp -&gt; Exp      //      | $e$ $\\oplus$ $e$\n    Fun     : ID * TypeExp * Exp -&gt; Exp     //      | fun ($x$ : $te$) { $e$ }\n    Var     : ID -&gt; Exp                     //      | $x$\n    App     : Exp * Exp -&gt; Exp              //      | $e$ $e$\n\n  sorts TypeExp constructors                // $te$ :=\n    NumType : TypeExp                       //       | num\n    FunType : TypeExp * TypeExp -&gt; TypeExp  //       | $te$ -&gt; $te$\n\n  sorts Type constructors\n    NUM   : Type\n    FUN   : Type * Type -&gt; Type\n\n  relations\n    typeOfDecl : occurrence -&gt; Type\n\n  namespaces\n    Var  : string\n\n  name-resolution\n    labels P R\n    resolve Var filter P* min $ &lt; P\n\nrules\n\n  typeOfExp : scope * Exp -&gt; Type\n\n  typeOfExp(s, Num(_)) = NUM().\n\n  typeOfExp(s, BinExp(e1, _, e2)) = NUM() :-\n    typeOfExp(s, e1) == NUM(),\n    typeOfExp(s, e2) == NUM().\n\n  typeOfExp(s, Fun(x, te, e)) = FUN(S, T) :- {s_fun}\n    typeOfTypeExp(s, te) == S,\n    new s_fun, s_fun -P-&gt; s,\n    s_fun -&gt; Var{x@x} with typeOfDecl S,\n    typeOfExp(s_fun, e) == T.\n\n  typeOfExp(s, Var(x)) = T :-\n    typeOfDecl of Var{x@x} in s |-&gt; [(_, (_, T))].\n\n  typeOfExp(s, App(e1, e2)) = T :- {S U}\n    typeOfExp(s, e1) == FUN(S, T),\n    typeOfExp(s, e2) == U,\n    U == S.\n\nrules\n\n  typeOfTypeExp : scope * TypeExp -&gt;  Type\n\n  typeOfTypeExp(s, NumType()) = NUM().\n\n  typeOfTypeExp(s, FunType(te1, te2)) = FUN(typeOfTypeExp(s, te1), typeOfTypeExp(s, te2)).\n\n</code></pre> \u00d7"},{"location":"statix.example/src/stlc.stx/#modal-h2","title":"stlc.stx","text":""},{"location":"statix.example/src/stlc.stxtest/","title":"<code>stlc.stxtest</code>","text":"<p> pdmosses/nabl/statix.example/src/stlc.stxtest</p> <pre><code>resolve {s T e}\n\n  new s, typeOfExp(s, e) == T\n\nsignature\n  sorts ID = string                         // $x$\n\n  sorts Exp constructors                    // $e$ :=\n    Unit    : Exp                           //      | ()\n    Fun     : ID * Type * Exp -&gt; Exp        //      | fun ($x$ : $T$) { $e$ }\n    Var     : ID -&gt; Exp                     //      | $x$\n    App     : Exp * Exp -&gt; Exp              //      | $e$ $e$\n    Let     : list(Bind) * Exp -&gt; Exp       //      | let $b*$ in $e$\n\n  sorts Bind constructors                   // $b$ :=\n    Bind : ID * Type * Exp -&gt; Bind          //      | $x$ : $T$ = $e$\n\n  sorts Type constructors\n    UNIT : Type\n    FUN  : Type * Type -&gt; Type\n\n  relations\n    typeOfDecl : occurrence -&gt; Type\n\n  namespaces\n    Var  : string\n\n  name-resolution\n    labels P\n    resolve Var filter P* min $ &lt; P\n\nrules\n\n  typeOfExp : scope * Exp -&gt; Type\n\n  typeOfExp(_, Unit()) = UNIT().\n\n  typeOfExp(s, Fun(x, S, e)) = FUN(S, T) :- {s_fun}\n    new s_fun, s_fun -P-&gt; s,\n    s_fun -&gt; Var{x@x} with typeOfDecl S,\n    typeOfExp(s_fun, e) == T.\n\n  typeOfExp(s, Var(x)) = T :- {p d}\n    typeOfDecl of Var{x@x} in s |-&gt; [(p, (d, T))].\n\n  typeOfExp(s, App(e1, e2)) = T :- {S U}\n    typeOfExp(s, e1) == FUN(S, T),\n    typeOfExp(s, e2) == U,\n    U == S.\n\n  typeOfExp(s, Let(binds, e)) = T :- {s_let}\n    new s_let, s_let -P-&gt; s,\n    bindsOk(s, binds, s_let),\n    typeOfExp(s_let, e) == T,\n    binds != []. // additive\n\n  bindOk : scope * Bind * scope\n\n  bindOk(s, Bind(x, T, e), s_bnd) :-\n    s_bnd -&gt; Var{x@x} with typeOfDecl T,\n    typeOfExp(s, e) == T.\n\n  bindsOk maps bindOk(*, list(*), *)\n\n</code></pre> \u00d7"},{"location":"statix.example/src/stlc.stxtest/#modal-h2","title":"stlc.stxtest","text":""},{"location":"statix.example/src/stlcrec-with-eval.stxtest/","title":"<code>stlcrec-with-eval.stxtest</code>","text":"<p> pdmosses/nabl/statix.example/src/stlcrec-with-eval.stxtest</p> <pre><code>resolve {e T v}\n\n  e == App(Fun(\"x\", UnitType(), Var(\"x\")), Unit()),\n\n  ({s} new s, T == typeOfExp(s, e)),\n\n  ({f} new f, v == evalExp(f, e))\n\nsignature\n\n  sorts ID = string                                  // x\n\n  sorts Exp constructors                             // e :=\n    Unit    : Exp                                    //    | unit\n    Fun     : ID * TypeExp * Exp -&gt; Exp              //    | fun (x : te) { e }\n    Var     : ID -&gt; Exp                              //    | x\n    App     : Exp * Exp -&gt; Exp                       //    | e e\n    Rec     : list(Bind) -&gt; Exp                      //    | { b* }\n    FAccess : Exp * ID -&gt; Exp                        //    | e.x\n    Let     : list(Bind) * Exp -&gt; Exp                //    | let b+ in e\n\n  sorts Bind constructors                            // b :=\n    Bind : ID * Exp -&gt; Bind                          //    | x = e\n\n  sorts TypeExp constructors                         // te :=\n    UnitType : TypeExp                               //     | unit\n    FunType  : TypeExp * TypeExp -&gt; TypeExp          //     | te -&gt; te\n    RecType  : list(Decl) -&gt; TypeExp                 //     | { d* }\n\n  sorts Decl constructors                            // d :=\n    Decl : ID * TypeExp -&gt; Decl                      //    | x : te\n\nsignature\n\n  sorts Type constructors\n    UNIT  : Type\n    FUN   : Type * Type -&gt; Type\n    REC   : scope -&gt; Type\n\n  relations\n    typeOfDecl : occurrence -&gt; Type\n\n  namespaces\n    Var  : string\n\n  name-resolution\n    labels P\n    resolve Var filter P* min $ &lt; P\n\nrules\n\n  programOK : Exp\n  programOK(e) :- {s T}\n    new s,\n    typeOfExp(s, e) == T.\n\nrules\n\n  typeOfExp : scope * Exp -&gt; Type\n\n  [T-Unit]\n  typeOfExp(s, Unit()) = UNIT().\n\n  [T-Fun]\n  typeOfExp(s, Fun(x, te, e)) = FUN(S, T) :- {s_fun}\n    typeOfTypeExp(s, te) == S,\n    new s_fun, s_fun -P-&gt; s,\n    s_fun -&gt; Var{x@x} with typeOfDecl S,\n    typeOfExp(s_fun, e) == T.\n\n  [T-Var]\n  typeOfExp(s, Var(x)) = T :- {d}\n    typeOfDecl of Var{x@x} in s |-&gt; [(_, (d, T))].\n\n  [T-App]\n  typeOfExp(s, App(e1, e2)) = T :- {S U}\n    typeOfExp(s, e1) == FUN(S, T),\n    typeOfExp(s, e2) == U,\n    subType(U, S).\n\n  [T-Rec]\n  typeOfExp(s, Rec(finits)) = REC(rs) :-\n    new rs, fieldInitsOK(s, finits, rs).\n\n  [T-Fld]\n  typeOfExp(s, FAccess(e, x)) = T :- {rs}\n    typeOfExp(s, e) == REC(rs),\n    typeOfDecl of /*Fld*/Var{x@x} in rs |-&gt; [(_, (_, T))].\n\n  [T-Let]\n  typeOfExp(s, Let(binds, e)) = T :- {s_let}\n    binds != [],\n    new s_let, s_let -P-&gt; s,\n    letBindsOK(s, binds, s_let),\n    typeOfExp(s_let, e) == T.\n\nrules\n\n  letBindOK : scope * Bind * scope\n  letBindsOK maps letBindOK(*, list(*), *)\n\n  [T-Bind]\n  letBindOK(s, Bind(x, e), s_bnd) :-\n    s_bnd -&gt; Var{x@x} with typeOfDecl typeOfExp(s, e).\n\nrules\n\n  fieldInitOK : scope * Bind * scope\n  fieldInitsOK maps fieldInitOK(*, list(*), *)\n\n  fieldInitOK(s, Bind(x, e), rs) :- {T}\n    rs -&gt; /*Fld*/Var{x@x} with typeOfDecl typeOfExp(s, e),\n    unique(x, rs).\n\n  unique : ID * scope\n  unique(x, s) :-\n    /*Fld*/Var{x@x} in s |-&gt; [_].\n\nrules\n\n  typeOfTypeExp : scope * TypeExp -&gt; Type\n\n  [TE-Unit]\n  typeOfTypeExp(s, UnitType()) = UNIT().\n\n  [TE-Fun]\n  typeOfTypeExp(s, FunType(te1, te2)) = FUN(T1, T2) :-\n    typeOfTypeExp(s, te1) == T1,\n    typeOfTypeExp(s, te2) == T2.\n\n  [TE-Rec]\n  typeOfTypeExp(s, RecType(ftypes)) = REC(rs) :-\n    new rs, fieldTypesOK(s, ftypes, rs).\n\nrules\n\n  fieldTypeOK : scope * Decl * scope\n  fieldTypesOK maps fieldTypeOK(*, list(*), *)\n\n  fieldTypeOK(s, Decl(x, te), rs) :-\n    rs -&gt; /*Fld*/Var{x@x} with typeOfDecl typeOfTypeExp(s, te),\n    unique(x, rs).\n\nrules\n\n  subType  : Type * Type\n  subField : scope * (path * occurrence)\n  subFields maps subField(*, list(*))\n\n  subType(UNIT(), UNIT()).\n\n  subType(FUN(S1, T1), FUN(S2, T2)) :- subType(S2, S1), subType(T1, T2).\n\n  subType(REC(s_sub), REC(s_sup)) :- subFields(s_sub, allFields(s_sup)).\n\n  subField(s_sub, (p_sup, d_sup@/*Fld*/Var{x@i})) :- {S T}\n    S == ?typeOfDecl[d_sup] in dst(p_sup),\n    typeOfDecl of /*Fld*/Var{x@i} in s_sub |-&gt; [(_, (_, T))],\n    subType(T, S).\n\n  allFields: scope -&gt; list((path * occurrence))\n  allFields(s) = ps :-\n    query decl\n          filter e and { /*Fld*/Var{_@_} }\n          min /* */ and { /*Fld*/Var{x@_}, /*Fld*/Var{x@_} }\n          in s |-&gt; ps.\n\nsignature\n\n  sorts Frame = scope\n\n  sorts Val constructors\n    UnitV : Val\n    ClosV : Frame * ID * Exp -&gt; Val\n\n  relations\n    val : occurrence -&gt; Val\n\nrules\n\n  evalExp : Frame * Exp -&gt; (Val * int)\n\n  [E-Unit]\n  evalExp(f, Unit()) = (UnitV(), 0).\n\n  [E-Fun]\n  evalExp(f, Fun(x, S, e)) = (ClosV(f, x, e), 0).\n\n  [E-Var]\n  evalExp(f, Var(x)) = (v, 0) :- {p d}\n    val of Var{x@x} in f |-&gt; [(p, (d, v))].\n\n  [E-App]\n  evalExp(f, App(e1, e2)) = (v, #(1 + k + k1 + k2)) :- {f_clos x e f_app v'}\n    evalExp(f, e1) == (ClosV(f_clos, x, e), k1),\n    evalExp(f, e2) == (v', k2),\n    new f_app, f_app -P-&gt; f_clos,\n    f_app -&gt; Var{x@x} with val v',\n    evalExp(f_app, e) == (v, k).\n\n  [E-Let]\n  evalExp(f, Let(binds, e)) = (v, #(k + k')) :- {f_let}\n    new f_let,\n    evalBinds(f, binds, f_let) == k',\n    evalExp(f_let, e) == (v, k).\n\n\n  evalBind : Frame * Bind * Frame -&gt; int\n\n  [E-Bind]\n  evalBind(f, Bind(x, e), f_bnd) = k :- {v}\n    evalExp(f, e) == (v, k),\n    f_bnd -&gt; Var{x@x} with val v.\n\n\n  evalBinds : Frame * list(Bind) * Frame -&gt; int\n\n  evalBinds(f, [], f_bnd) = 0.\n\n  evalBinds(f, [bind|binds], f_bnd) = #(k + k') :-\n    evalBind(f, bind, f_bnd) == k,\n    evalBinds(f, binds, f_bnd) == k'.\n\n\nrules\n\n  dst : path -&gt; scope\n  dst(_PathEmpty(s)) = s.\n  dst(_PathStep(_, _, s)) = s.\n\n\n</code></pre> \u00d7"},{"location":"statix.example/src/stlcrec-with-eval.stxtest/#modal-h2","title":"stlcrec-with-eval.stxtest","text":""},{"location":"statix.example/src/subtype-overloading.stxtest/","title":"<code>subtype-overloading.stxtest</code>","text":"<p> pdmosses/nabl/statix.example/src/subtype-overloading.stxtest</p> <pre><code>/** Type-based overload resolution with subtyping\n                      * Goal:\n                      * Result:\n                      * - Function resolution does select compatible functions based on the `subType`\n                      *   relation.\n                      * - Currently there is now way to select the _best_ compatible function.\n                      */\nresolve {s result}\n\n  new s,\n  s -&gt; Fun{\"f\"@-} with funType INT(),\n  s -&gt; Fun{\"f\"@-} with funType NAT(),\n  s -&gt; Fun{\"f\"@-} with funType POS(),\n  resolveFun(s, Fun{\"f\"@-}, NAT()) == result\n\nsignature\n\n  sorts ID = string\n\n  sorts TYPE constructors\n    INT : TYPE\n    NAT : TYPE\n    POS : TYPE\n\n  namespaces\n    Fun : ID\n\n  relations\n    funType : occurrence * TYPE\n\nrules\n\n  resolveFun : scope * occurrence * TYPE -&gt; list((occurrence * TYPE))\n\n  resolveFun(s, Fun{x@_}, T) = pots2ots(funs) :- {}\n    query funType\n      filter ~0 and { (Fun{y@_}, U) :- x == y, subType(T, U) }\n      min and { (_, T1), (_, T2) :- subType(T1, T2) }\n      in s\n      |-&gt; funs.\n\nrules\n\n  subType : TYPE * TYPE\n\n  subType(T, T).\n  subType(POS(), NAT()).\n  subType(POS(), INT()).\n  subType(NAT(), INT()).\n\nrules\n\n  pots2ots maps pot2ot(list(*)) = list(*)\n  pot2ot : (path * (occurrence * TYPE)) -&gt; (occurrence * TYPE)\n  pot2ot((_, ot)) = ot.\n\n</code></pre> \u00d7"},{"location":"statix.example/src/subtype-overloading.stxtest/#modal-h2","title":"subtype-overloading.stxtest","text":""},{"location":"statix.example/src/type-classes.stxtest/","title":"<code>type-classes.stxtest</code>","text":"<p> pdmosses/nabl/statix.example/src/type-classes.stxtest</p> <pre><code>/** Type-classes a la Haskell\n                      * Goal:\n                      * Limitations:\n                      * - No support for non-linear patterns\n                      * Result:\n                      */\nresolve {s m}\n\n  m == Module([\n\n//  class () =&gt; Eq a where\n//    eq :: a -&gt; a -&gt; Bool   -- eq :: Eq a =&gt; a -&gt; a -&gt; Bool\n    ClassDef([], \"Eq\", TVar(\"a\"), [\n      Fun(\"eq\", [TVar(\"a\"), TVar(\"a\")], Bool(), [])\n    ])\n\n//  instance () =&gt; Eq Bool where\n//    eq True True = True \n//    eq False False = True \n  , InstanceDef([], \"Eq\", Bool(), [\n      Fun(\"eq\", [Bool(), Bool()], Bool(), [\n        Case([True() , True() ], Term(True()))\n      , Case([False(), False()], Term(True()))\n      ])\n    ])\n\n// instance Eq a =&gt; Eq (a * a) where\n//  (x1, x2) == (y1, y2) = x1 == y1 &amp;&amp; x2 == y2\n\n  ]),\n\n  new s,\n  moduleOk(s, m),\n  instanceOf(s, \"Eq\", Bool()) == _\n\nsignature\n\n  sorts ID = string\n\n  sorts Module constructors\n    Module : list(Def) -&gt; Module\n\n  sorts Def constructors\n    ClassDef    : list(TC) * ID * Type * list(FunDef) -&gt; Def\n    InstanceDef : list(TC) * ID * Type * list(FunDef) -&gt; Def\n\n  sorts Type constructors\n    Bool : Type\n    Int  : Type\n    TVar : ID -&gt; Type\n\n  sorts FunDef constructors\n    Fun : ID * list(Type) * Type * list(FunCase) -&gt; FunDef\n\n  sorts FunCase constructors\n    Case : list(Term) * Exp -&gt; FunCase\n\n  sorts Exp constructors\n    App  : ID * list(Exp) -&gt; Exp\n    Term : Term -&gt; Exp\n\n  sorts Term constructors\n    True  : Term\n    False : Term\n    Var   : ID -&gt; Term\n\nsignature\n\n  sorts TYPE constructors\n    CLASS : Type * scope -&gt; TYPE\n    FUN   : list(TC) * list(Type) * Type -&gt; TYPE\n\n  sorts TC constructors\n    TC : ID * Type -&gt; TC\n\n  namespaces\n    Class    : ID\n    Instance : ID\n    Fun      : ID\n\n  name-resolution\n    labels P\n    resolve Class filter P* min $ &lt; P\n    resolve Instance filter P* min $ &lt; P\n    resolve Fun filter P* min $ &lt; P\n\n  relations\n    type  : occurrence * TYPE\n    subst : string -&gt; Type\n\nrules\n\n  moduleOk : scope * Module\n\n  moduleOk(s, Module(defs)) :-\n    defsOk(s, defs).\n\nrules\n\n  defsOk maps defOk(*, list(*))\n\n  defOk : scope * Def    \n\n  defOk(s, ClassDef([], x, ty, funs)) :- {s_class}\n    varType(ty),\n    new s_class,\n    s -&gt; Class{x@x} with type CLASS(ty, s_class).\n\n  defOk(s, InstanceDef([], x, ty, funs)) :- {s_inst}\n    headNormalType(ty),\n    new s_inst,\n    s -&gt; Instance{x@x} with type CLASS(ty, s_inst).\n\nrules\n\n  varType : Type\n  varType(TVar(_)).\n\n  headNormalType : Type\n  headNormalType(TVar(_)) :- false.\n  headNormalType(_).\n\nrules\n\n  instanceOf : scope * string * Type -&gt; (occurrence * scope)\n\n  instanceOf(s, x, ty) = (d, s_inst) :- {ty_inst}\n    query type\n      filter P*\n          and { (Instance{x_inst@_}, CLASS(ty_inst, _)) :- x == x_inst, match(ty, ty_inst) }\n      min $ &lt; P and true\n      in s |-&gt; [(_, (d, CLASS(ty_inst, s_inst)))].\n\nrules\n\n  match : Type * Type\n\n  match(P, T) :- matchIn(new, P, T).\n\n  matchIn : scope * Type * Type\n\n  matchIn(s, TVar(x), T) :-\n    !subst[x, T] in s.\n\n  matchIn(s, Bool(), Bool()).\n\n</code></pre> \u00d7"},{"location":"statix.example/src/type-classes.stxtest/#modal-h2","title":"type-classes.stxtest","text":""},{"location":"statix.example/src/busybeaver/bb-rules.stx/","title":"<code>bb-rules.stx</code>","text":"<p> pdmosses/nabl/statix.example/src/busybeaver/bb-rules.stx</p> <pre><code>// 3-state Busy Beaver Turing machine specification\n// https://en.wikipedia.org/wiki/Turing_machine_examples#3-state_Busy_Beaver\n\nmodule busybeaver/bb-rules\n\nimports\n\n  busybeaver/bb-sig\n\nrules\n\n  busybeaver : State * Tape\n\n  busybeaver(A(), (left, Zero(), right)) :-\n    busybeaver(B(), move((left, One(), right), R())).\n\n  busybeaver(A(), (left, One(), right)) :-\n    busybeaver(C(), move((left, One(), right), L())).\n\n  busybeaver(B(), (left, Zero(), right)) :-\n    busybeaver(A(), move((left, One(), right), L())).\n\n  busybeaver(B(), (left, One(), right)) :-\n    busybeaver(B(), move((left, One(), right), L())).\n\n  busybeaver(C(), (left, Zero(), right)) :-\n    busybeaver(B(), move((left, One(), right), L())).\n\n  busybeaver(C(), (left, One(), right)) :-\n    busybeaver(HALT(), move((left, One(), right), R())).\n\n  busybeaver(HALT(), (left, s, right)).\n\nrules\n\n  move : Tape * Move -&gt; Tape\n\n  move((left, s, [s'|right]), R()) = ([s|left], s', right).\n\n  move((left, s, []), R()) = ([s|left], Zero(), []).\n\n  move(([s'|left], s, right), L()) = (left, s', [s|right]).\n\n  move(([], s, right), L()) = ([], Zero(), [s|right]).\n\n  move(T, N()) = T.\n\n</code></pre> \u00d7"},{"location":"statix.example/src/busybeaver/bb-rules.stx/#modal-h2","title":"bb-rules.stx","text":""},{"location":"statix.example/src/busybeaver/bb-sig.stx/","title":"<code>bb-sig.stx</code>","text":"<p> pdmosses/nabl/statix.example/src/busybeaver/bb-sig.stx</p> <pre><code>// 3-state Busy Beaver Turing machine specification\n// https://en.wikipedia.org/wiki/Turing_machine_examples#3-state_Busy_Beaver\n\nmodule busybeaver/bb-sig\n\nsignature\n\n  sorts State constructors\n    A    : State\n    B    : State\n    C    : State\n    HALT : State\n\n  sorts Symbol constructors\n    Zero : Symbol\n    One  : Symbol\n\n  sorts Move constructors\n    R : Move\n    L : Move\n    N : Move\n\n  sorts Tape = (list(Symbol) * Symbol * list(Symbol))\n\n</code></pre> \u00d7"},{"location":"statix.example/src/busybeaver/bb-sig.stx/#modal-h2","title":"bb-sig.stx","text":""},{"location":"statix.example/src/busybeaver/bb-test.stxtest/","title":"<code>bb-test.stxtest</code>","text":"<p> pdmosses/nabl/statix.example/src/busybeaver/bb-test.stxtest</p> <pre><code>// 3-state Busy Beaver Turing machine specification\n// https://en.wikipedia.org/wiki/Turing_machine_examples#3-state_Busy_Beaver\n\nresolve\n\n  busybeaver(A(), ([], Zero(), []))\n\nimports\n\n  busybeaver/bb-sig\n  busybeaver/bb-rules\n\n</code></pre> \u00d7"},{"location":"statix.example/src/busybeaver/bb-test.stxtest/#modal-h2","title":"bb-test.stxtest","text":""},{"location":"statix.example/src/overlapping-rules/linear-patterns.stx/","title":"<code>linear-patterns.stx</code>","text":"<p> pdmosses/nabl/statix.example/src/overlapping-rules/linear-patterns.stx</p> <pre><code>module overlapping-rules/linear-patterns\n\nsignature\n  sorts S constructors\n    F : int -&gt; S\n    G : S\n    H : S * S -&gt; S\n\nrules\n\n  // p01 No general case\n  p01 : list(int)\n  p01([_]).\n\nrules\n\n  // p02 Top-level general case\n  p02 : list(int)\n  p02([]).\n  p02(xs). // p02(xs@[_|_]).\n\nrules\n\n  // p03 Nested case\n  p03 : list(int)\n  p03([_]).\n  p03([_|xs]). // p03([_|xs@[_|_]]).\n\nrules\n\n  p06 : list(int) * list(int)\n  p06([], ys).\n  p06(xs, []). // p06(xs@[_|_], []).\n  p06(xs, ys). // p06(xs@[_|_], [_|_]).\n\nrules\n\n  p07 : S\n  p07(x).\n\nrules\n\n  p08 : S\n  p08(F(_)).\n  p08(G()).\n\nrules\n\n  p10 : S\n  p10(H(G(), _)).\n  p10(H(_, _)). // p10(H(F(_), _))\n                // p10(H(H(_, _), _))\n\nrules\n\n  p11 : S * S\n  p11(F(_), G()).\n  p11(G(), x).\n\nrules\n\n  p12 : S * S\n  p12(F(_), x).\n  p12(G(), x).\n\nrules\n\n  p18 : S\n  p18(F(_)).\n  p18(x@G()).\n\nrules\n\n  p19 : S\n  p19(H(G(), _)).\n  p19(x). // p19(x@F(_)).\n          // p19(x@G()).\n          // p19(x@H(F(_), _)).\n          // p19(x@H(H(_, _), _)).\n\nrules\n\n  p20 : list(int)\n  p20([_]).\n  p20(xs). // p20(xs@[]).\n           // p20(xs@[_,_|_]).\n\nrules\n\n  p21 : string\n  p21(\"x\").\n  p21(\"y\").\n  p21(\"z\").\n//p21(_). // not supported\n\nrules\n\n  p22 : int\n  p22(1).\n  p22(2).\n  p22(4).\n//p22(_). // not supported\n\nrules\n\n  p23 : S * S\n  p23(G(), G()).\n  p23(G(), _).\n  p23(_, G()).\n  p23(_, _).\n\nrules\n\n  p24 : S * S\n  p24(G(), G()).\n  p24(G(), _).\n  p24(_, _).\n\n</code></pre> \u00d7"},{"location":"statix.example/src/overlapping-rules/linear-patterns.stx/#modal-h2","title":"linear-patterns.stx","text":""},{"location":"statix.example/src/overlapping-rules/nonlinear-patterns.stx/","title":"<code>nonlinear-patterns.stx</code>","text":"<p> pdmosses/nabl/statix.example/src/overlapping-rules/nonlinear-patterns.stx</p> <pre><code>module overlapping-rules/nonlinear-patterns\n\nsignature\n  sorts S constructors\n    F : int -&gt; S\n    G : S\n    H : S * S -&gt; S\n\nrules\n\n  // FIXME\n  p04 : int * int\n  p04(x,x). // p04(x,y) :- x == y.\n  p04(x,y). // p04(x,y) :- x != y.\n\nrules  \n\n  p05 : list(int) * int\n  p05(xs@[y], y).\n  p05(xs, y). // p05(xs@[], y).\n              // p05(xs@[_|[_|_]], y).\n\nrules\n\n  p09 : S * S\n  p09(x@G(), x).\n  p09(x, y). // p09(x@F(_), y).\n             // p09(x@H(_, _), y).\n\nrules\n\n  // TODO Are the inequalities necessary, and correct?\n  p13 : int * int * int\n  p13(x, x, y). // p13(x, z, y) :- x == z, x != y.\n  p13(x, y, x). // p13(x, y, z) :- x == z, x != y.\n\nrules\n\n  p14 : S\n//p14(x@F(x)).\n\nrules\n\n  p15 : S * S\n//p15(H(x@F(_),G()),x).\n//p15(H(F(_),x@G()),x).\n\nrules\n\n  p16 : S * S\n//p16(H(x@G(),G()),x).\n//p16(H(G(),x@G()),x).\n\nrules\n\n  p17 : S * S\n  p17(x@G(),x).\n  p17(G(),x).\n\n</code></pre> \u00d7"},{"location":"statix.example/src/overlapping-rules/nonlinear-patterns.stx/#modal-h2","title":"nonlinear-patterns.stx","text":""},{"location":"statix.lang/","title":"Statix","text":"<p>Statix is a meta-language for the specification of static semantics in Spoofax.</p> <p>Statix specifications are organised in modules. In Statix, programs, types and all other data are represented using terms. Type-checking a program is performed by solving a set of constraints over terms. In addition to these built-in constraints, specification writers can define their own constraints.</p> <p>Type-checking is closely related to, and strongly intertwined with, name resolution. For that reason, Statix has built-in support for modelling name binding patterns in the form of scope graphs. During type-checking, names can be resolved using queries.</p> <p>The Statix documentation explains the details.</p> <p>Statix supersedes the deprecated NaBL and NaBL2 meta-languages.</p> <p>Statix has not yet been used in Spoofax 2 for specifying the name binding of meta-languages. It has however been used for specifying languages in the MetaBorgCube, e.g., Tiger.</p>"},{"location":"statix.lang/#syntax","title":"Syntax","text":"<p><code>syntax/StatixLang.sdf3</code></p> <p>The syntax of Statix is specified in SDF3.</p>"},{"location":"statix.lang/#name-binding","title":"Name binding","text":"<p>The name binding of Statix is specified in NaBL2.<sup>1</sup></p> <ol> <li> <p>The name binding of NaBL2 definitions has not been specified, so browsing them is not supported by hyperlinked twins.\u00a0\u21a9</p> </li> </ol>"},{"location":"statix.lang/src-gen/syntax/permissive-water.sdf3/","title":"<code>permissive-water.sdf3</code>","text":"<pre><code>module permissive-water\n\n// Key idea: WATER is the inverse of LAYOUT\n\ncontext-free syntax\n  // Allow WATER on places where LAYOUT may occur\n  LAYOUT.WATER = WATER\n\nlexical sorts\n  WATER\n  WATERTOKEN\n  WATERTOKENSTART\n  WATERTOKENSEPARATOR\n\nlexical syntax\n  // Separate water regions into smaller chunks for recovery costs calculation\n  WATER = WATERTOKEN\n  WATER = WATERTOKENSEPARATOR\n\n  // Allow to skip over identifier strings\n  WATERTOKEN      = WATERTOKENSTART [A-Za-z0-9\\_]*\n  WATERTOKENSTART = [A-Za-z0-9\\_] {recover}\n\n  // Allow to skip over special characters that are neither part of identifiers nor whitespace characters\n  WATERTOKENSEPARATOR = ~[A-Za-z0-9\\_\\ \\t\\12\\r\\n\\*] {recover}\n\nlexical restrictions\n  WATERTOKEN -/- [A-Za-z0-9\\_]\n</code></pre> \u00d7"},{"location":"statix.lang/src-gen/syntax/permissive-water.sdf3/#modal-h2","title":"permissive-water.sdf3","text":""},{"location":"statix.lang/syntax/StatixLang.sdf3/","title":"<code>StatixLang.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/StatixLang.sdf3</p> <pre><code>module StatixLang\n\nimports\n\n  statix/lang/Layout\n  statix/lang/Common\n  statix/lang/Core\n  statix/lang/Sugar\n  statix/lang/PreCompiled\n  statix/lang/Deprecated\n\n  statix/test/Test\n\n  statix/cli/CLI\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\ncontext-free start-symbols\n\n  Start\n\n  LabelRE // for testing\n\ncontext-free syntax\n\n  Start = Module\n  Start = Test\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/StatixLang.sdf3/#modal-h2","title":"StatixLang.sdf3","text":""},{"location":"statix.lang/syntax/statix/cli/CLI.sdf3/","title":"<code>CLI.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/cli/CLI.sdf3</p> <pre><code>module statix/cli/CLI\n\nimports\n\n  statix/lang/Layout\n  statix/lang/Common\n  statix/lang/Core\n  statix/lang/Sugar\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\ncontext-free start-symbols\n\n  CommandLine\n\ncontext-free syntax\n\n  CommandLine.Eval = &lt;&lt;Constraint&gt;&gt;\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/cli/CLI.sdf3/#modal-h2","title":"CLI.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Common.sdf3/","title":"<code>Common.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Common.sdf3</p> <pre><code>module statix/lang/Common\n\nlexical syntax\n\n  INT = [0-9]+\n\n  ID     = [a-zA-Z] [a-zA-Z0-9\\_]*\n  UCID   = [A-Z]    [a-zA-Z0-9\\_]*\n  LCID   = [a-z]    [a-zA-Z0-9\\_]*\n  VARID  = [a-zA-Z] [a-zA-Z0-9\\_]* [\\']*\n\n  // more liberal ID to accept most Stratego sort and op identifiers\n  STRID = [A-Z] [a-zA-Z0-9\\_\\-\\']*\n//STRID = [a-z] [a-zA-Z0-9\\_\\-\\']* // leads to ambiguities with COp\n\n  FileId   = [a-zA-Z0-9\\_\\-\\.\\~\\']+\n  ModuleId = FileId (\"/\" FileId)*\n\nlexical restrictions\n\n  ID    -/- [a-zA-Z0-9\\_\\']\n  UCID  -/- [a-zA-Z0-9\\_\\']\n  LCID  -/- [a-zA-Z0-9\\_\\']\n  VARID -/- [a-zA-Z0-9\\_\\']\n\n  STRID -/- [a-zA-Z0-9\\_\\-\\']\n\n  FileId   -/- [a-zA-Z0-9\\_\\-\\.\\~\\']\n  ModuleId -/- [\\/]\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Common.sdf3/#modal-h2","title":"Common.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Core.sdf3/","title":"<code>Core.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Core.sdf3</p> <pre><code>module statix/lang/Core\n\nimports\n\n  statix/lang/Common\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\n\n/******************************************************************\n * Modules                                                        *\n ******************************************************************/\n\ncontext-free syntax\n\n  Module.Module = &lt;\n    module &lt;ModuleId&gt;\n\n    &lt;{Section \"\\n\\n\"}*&gt;\n  &gt; {longest-match}\n\n  Section.Imports = &lt;\n    imports\n      &lt;{Import \"\\n\"}*&gt;\n  &gt;\n\n  Import.Import = ModuleId\n\n  Section.Signature = &lt;\n    signature\n\n      &lt;{Signature \"\\n\\n\"}*&gt;\n  &gt; {longest-match}\n\n  Section.Rules = &lt;\n    rules\n\n      &lt;{Rule \"\\n\\n\"}*&gt;\n  &gt; {longest-match}\n\nlexical syntax\n\n  ModuleId = Keyword {reject}\n\n  Keyword = \"module\" | \"imports\" | \"signature\" | \"rules\"\n\n\n/******************************************************************\n * User Constraints                                               *\n ******************************************************************/\n\ncontext-free syntax\n\n  Signature.Constraints = &lt;\n    constraints\n      &lt;{CDecl \"\\n\"}*&gt;\n  &gt; {longest-match}\n\n  CDecl.CDecl      = [[CInd][ConstraintId] : [Type]]\n\n  CInd.InductiveC   =\n  CInd.CoinductiveC = &lt;coinductive &gt;\n\n  Rule.Rule = &lt;\n    &lt;RuleName&gt;&lt;RuleHead&gt; :-\n      &lt;Constraint&gt;.\n  &gt;\n\n  RuleName.NoName = &lt;&gt;\n  RuleName.Name = &lt;\n    [&lt;STRID&gt;]\n  &gt;\n  RuleHead.C = [[ConstraintId]([{Term \", \"}*])]\n\n  Constraint.C = [[ConstraintId]([{Term \", \"}*])[Message]]\n\n  HoConstraint.LLam = &lt;{ &lt;{Term \", \"}*&gt; :- &lt;Constraint&gt; }&gt;\n\nlexical syntax\n\n  ConstraintId = LCID\n  ConstraintId = Keyword {reject}\n\n  Keyword = \"constraints\" | \"coinductive\"\n\n\n/******************************************************************\n * Base Constraints                                               *\n ******************************************************************/\n\ncontext-free syntax\n\n  Constraint.CTrue  = &lt;true&gt;\n  Constraint.CFalse = &lt;false&lt;Message&gt;&gt;\n\n  Constraint         = &lt;(&lt;Constraint&gt;)&gt; {bracket}\n\n  Constraint.CConj   = &lt;\n    &lt;Constraint&gt;,\n    &lt;Constraint&gt;\n  &gt; {right}\n\n  Constraint.CNew    = &lt;new &lt;{Var \" \"}+&gt;&gt;\n\n  Constraint.CEqual   = [[Term] == [Term][Message]]\n  Constraint.CInequal = [[Term] != [Term][Message]]\n\n  Constraint.CTry = [try { [Constraint] }[Message]]\n\n  Constraint.CExists = [\n    {[{Var \" \"}*]}\n      [Constraint]\n  ]\n\ncontext-free priorities\n\n  // Does this give longest-match behavior? Putting longest-match on CExists\n  // seemed to break parsing of exists with conj body in parenthesis.\n  Constraint.CConj &gt; Constraint.CExists\n\nlexical syntax\n\n  Keyword = \"true\" | \"false\" | \"new\" | \"try\"\n\n\n/******************************************************************\n * AST Constraints                                                *\n ******************************************************************/\n\ncontext-free syntax\n\n  Constraint.CAstId       = &lt;astId(&lt;Term&gt;, &lt;Term&gt;)&gt;\n  Constraint.CAstProperty = &lt;@&lt;TermOrTermIndex&gt;.&lt;AstProperty&gt; &lt;AstPropertyOp&gt; &lt;Term&gt;&gt;\n\n  AstProperty.Prop = AstPropertyId\n\n  AstPropertyOp.Set = \":=\"\n  AstPropertyOp.Add = \"+=\"\n\n  TermOrTermIndex = Var\n\nlexical syntax\n\n  AstPropertyId = ID\n  AstPropertyId = Keyword {reject}\n\n  Keyword = \"astId\"\n\n\n/******************************************************************\n * Relations                                                      *\n ******************************************************************/\n\ncontext-free syntax\n\n  Signature.Relations = &lt;\n    relations\n      &lt;{RelDecl \"\\n\"}*&gt;\n  &gt; {longest-match}\n\n  RelDecl.RelDecl = &lt;&lt;Label&gt; : &lt;Type&gt;&gt;\n\n  RelRef = Label\n\n  Rule = &lt;relation &lt;RelDecl&gt;&gt;\n\nsyntax\n\n  Constraint-CF.CTellRel = \"!\" RelRef-CF \"[\" CommaTerms-CF \"]\" LAYOUT?-CF \"in\" LAYOUT?-CF Term-CF\n\nlexical syntax\n\n  RelationId = ID\n  RelationId = Keyword {reject}\n\n  Keyword = \"relations\" | \"relation\" | \"in\"\n\n\n/******************************************************************\n * Scope Graph                                                    *\n ******************************************************************/\n\ncontext-free syntax\n\n  Signature.NameResolution = &lt;\n    name-resolution\n      &lt;{ResolutionParam \"\\n\"}*&gt;\n  &gt; {longest-match}\n\n  // labels\n\n  ResolutionParam.Labels = &lt;labels &lt;{Label \" \"}*&gt;&gt;\n\n  Label.Label = RelationId\n\n  EdgeRef     = Label\n  EdgeRef.EOP = \"$\"\n\n  LabelPairs          = &lt;&lt;{LabelPair \", \"}*&gt;&gt;\n  LabelPair.LabelPair = [[EdgeRef] &lt; [EdgeRef]]\n  LabelOrd            = LabelPairs\n\n  LabelRE.Empty      = &lt;0&gt;\n  LabelRE.Epsilon    = &lt;e&gt;\n//LabelRE.Any        = &lt;.&gt;\n  LabelRE            = Label\n  LabelRE.Closure    = &lt;&lt;LabelRE&gt;*&gt;\n  LabelRE.Neg        = &lt;~&lt;LabelRE&gt;&gt;\n  LabelRE.Concat     = &lt;&lt;LabelRE&gt; &lt;LabelRE&gt;&gt;     {right}\n  LabelRE.And        = &lt;&lt;LabelRE&gt; &amp; &lt;LabelRE&gt;&gt;   {left}\n  LabelRE.Or         = &lt;&lt;LabelRE&gt; | &lt;LabelRE&gt;&gt;   {left}\n  LabelRE            = &lt;(&lt;LabelRE&gt;)&gt;             {bracket}\n\ncontext-free priorities\n\n    { LabelRE.Neg LabelRE.Closure }\n  &gt; LabelRE.Concat\n  &gt; LabelRE.And\n  &gt; LabelRE.Or\n\ncontext-free syntax\n\n  Term = Path\n\n  Path = PathLit\n\nsyntax\n\n  PathLit-CF.PathEmpty = \"_PathEmpty\" \"(\" LAYOUT?-CF Term-CF LAYOUT?-CF \")\"\n  PathLit-CF.PathStep  = \"_PathStep\" \"(\" LAYOUT?-CF Term-CF LAYOUT?-CF \",\" LAYOUT?-CF Term-CF LAYOUT?-CF \",\" LAYOUT?-CF Term-CF LAYOUT?-CF \")\"\n\n  Constraint-CF.CTellEdge = Term-CF LAYOUT?-CF \"-\" Label-CF \"-&gt;\" LAYOUT?-CF Term-CF\n\nlexical syntax\n\n  NamespaceId = UCID\n\n  RelationId = \"e\" {reject}        // ambiguous with empty regex\n  RelationId = Keyword {reject}    // ambiguous with signature keywords\n\n  Keyword = \"namespaces\" | \"name-resolution\" | \"labels\" | \"namespace\"\n\n\n/******************************************************************\n * Resolve &amp; Query\n ******************************************************************/\n\ncontext-free syntax\n\n  Constraint = CResolveQuery\n\n  CResolveQuery.CResolveQuery = [\n    query [QueryTarget]\n     [QueryFilter]\n     [QueryMin]\n     [QueryProject]\n      in [Term] |-&gt; [Term][Message]\n   ]\n\n  QueryTarget.EOP = \"()\"\n  QueryTarget     = RelRef\n\n  QueryFilter.Filter   = &lt; filter &lt;LabelRE&gt; and &lt;HoConstraint&gt;&gt;\n  QueryMin.Min         = &lt; min &lt;LabelOrd&gt; and &lt;HoConstraint&gt;&gt;\n  QueryProject.Project = &lt; project &lt;ProjectTarget&gt;&gt;\n\n  ProjectTarget.PFull       = &lt;*&gt;\n  ProjectTarget.PTargetData = &lt;dst, $&gt;\n  ProjectTarget.PData       = &lt;$&gt;\n\nlexical syntax\n\n  Keyword = \"query\" | \"in\" | \"filter\" | \"min\" | \"project\" | \"and\"\n\n\n/******************************************************************\n * Sorts &amp; Constructors                                           *\n ******************************************************************/\n\ncontext-free syntax\n\n  Signature.Sorts = &lt;\n    sorts\n      &lt;{SortDecl \"\\n\"}*&gt;\n  &gt; {longest-match}\n\n  Signature.Constructors = &lt;\n    constructors\n      &lt;{OpDecl \"\\n\"}*&gt;\n  &gt; {longest-match}\n\n  SortDecl.SortDecl  = SortId\n  SortDecl.SortAlias = &lt;&lt;SortId&gt; = &lt;SortRef&gt;&gt;\n\n  Sort.SimpleSort = SortId\n\n  SortRef                = Sort\n  SortRef.ListSort       = &lt;list(&lt;SortRef&gt;)&gt;\n  SortRef.Tuple0Sort     = &lt;( )&gt;\n  SortRef.TupleNSort     = &lt;(&lt;SortRef&gt; * &lt;{SortRef \" * \"}+&gt;)&gt;\n  SortRef.IntSort        = \"int\"\n  SortRef.StringSort     = \"string\"\n  SortRef.PathSort       = \"path\"\n  SortRef.LabelSort      = \"label\"\n  SortRef.OccurrenceSort = \"occurrence\"\n  SortRef.ScopeSort      = \"scope\"\n  SortRef.AstIdSort      = \"astId\"\n  SortRef                = &lt;(&lt;SortRef&gt;)&gt; {bracket}\n\n  OpDecl.OpDecl  = &lt;&lt;OpId&gt; : &lt;OpSort&gt;&gt;\n\n  OpSort.ConstOp = Sort\n  OpSort.ArrowOp = [[{SortRef \" * \"}+] -&gt; [Sort]]\n\n  Type.SimpleType = [[{SortRef \" * \"}*]]\n\nlexical syntax\n\n  SortId = STRID\n  SortId = Keyword {reject}\n  SortId = \"list\" | \"int\" | \"string\" | \"occurrence\" | \"scope\" | \"path\" | \"label\" | \"astId\" {reject}\n\n  OpId = STRID\n  OpId = Keyword {reject}\n\n  Keyword = \"sorts\" | \"constructors\"\n\n\n/******************************************************************\n * Terms                                                          *\n ******************************************************************/\n\ncontext-free syntax\n\n  Var.Var = VARID\n  Var.Wld = &lt;_&gt;\n\n  Int.Int = INT\n\n  Term            = Var\n  Term            = Int\n  Term            = Str\n  Term.List       = &lt;[&lt;{Term \", \"}*&gt;]&gt;\n  Term.ListTail   = &lt;[&lt;{Term \", \"}*&gt;|&lt;Term&gt;]&gt;\n  Term.Tuple0     = &lt;( )&gt;\n  Term.TupleN     = &lt;(&lt;Term&gt;, &lt;{Term \", \"}+&gt;)&gt;\n  Term.As         = &lt;&lt;Var&gt;@&lt;Term&gt;&gt;\n  Term.Ascribe    = &lt;&lt;Term&gt; : &lt;SortRef&gt;&gt;\n  Term            = &lt;(&lt;Term&gt;)&gt; {bracket}\n\n  CommaTerms = &lt;&lt;{Term \", \"}*&gt;&gt;\n  SpaceTerms = &lt;&lt;{Term \" \"}*&gt;&gt;\n\ncontext-free priorities\n\n    Term.As\n  &gt; Term.Ascribe\n\nsyntax\n\n  Term-CF.Op         = OpId-LEX \"(\" LAYOUT?-CF CommaTerms-CF LAYOUT?-CF \")\"\n\n  Str-CF.Str        = \"\\\"\" StrChars-LEX \"\\\"\"\n\nlexical syntax\n\n  StrChars   = StrChar*\n  StrChar    = ~[\\\"\\\\\\t\\r\\n]\n  StrChar    =  \"\\\\\\\"\" | \"\\\\\\\\\" | \"\\\\t\" | \"\\\\r\" | \"\\\\n\"\n\nlexical restrictions\n\n  StrChars -/- ~[\\\"]\n\n\n/******************************************************************\n * Arithmetic                                                          *\n ******************************************************************/\n\nsyntax\n\n  Constraint-CF.CArith = ArithExp-CF LAYOUT?-CF \"#\" ArithOp-CF LAYOUT?-CF ArithExp-CF LAYOUT?-CF Message-CF\n\n  ArithOp-CF.Equal            = \"=\"\n  ArithOp-CF.NotEqual         = \"\\\\=\"\n  ArithOp-CF.GreaterThanEqual = \"&gt;=\"\n  ArithOp-CF.LessThanEqual    = \"=&lt;\"\n  ArithOp-CF.GreaterThan      = \"&gt;\"\n  ArithOp-CF.LessThan         = \"&lt;\"\n\ncontext-free syntax\n\n  ArithExp     = Int\n  ArithExp     = Var\n  ArithExp.Add = &lt;&lt;ArithExp&gt; + &lt;ArithExp&gt;&gt; {left}\n  ArithExp.Mul = &lt;&lt;ArithExp&gt; * &lt;ArithExp&gt;&gt; {left}\n  ArithExp.Sub = &lt;&lt;ArithExp&gt; - &lt;ArithExp&gt;&gt; {left}\n  ArithExp.Min = &lt;min(&lt;ArithExp&gt;, &lt;ArithExp&gt;)&gt;\n  ArithExp.Max = &lt;max(&lt;ArithExp&gt;, &lt;ArithExp&gt;)&gt;\n  ArithExp.Mod = &lt;&lt;ArithExp&gt; mod &lt;ArithExp&gt;&gt; {left}\n  ArithExp.Div = &lt;&lt;ArithExp&gt; div &lt;ArithExp&gt;&gt; {left}\n  ArithExp     = &lt;(&lt;ArithExp&gt;)&gt; {bracket}\n\ncontext-free priorities\n\n    {left: ArithExp.Mul ArithExp.Div ArithExp.Mod}\n  &gt; {left: ArithExp.Add ArithExp.Sub}\n\n\n/******************************************************************\n * Messages                                                       *\n ******************************************************************/\n\ncontext-free syntax\n\n  Message.NoMessage =\n  Message.Message   = &lt; | &lt;MessageKind&gt; &lt;MessageContent&gt; &lt;MessageOrigin&gt;&gt;\n\n  MessageKind.Error      = &lt;error&gt;\n  MessageKind.Warning    = &lt;warning&gt;\n  MessageKind.Note       = &lt;note&gt;\n\nsyntax\n\n  MessageContent-CF.Formatted = \"$[\" MessageContentPart-CF* \"]\"\n\n  MessageOrigin-CF.NoOrigin =\n  MessageOrigin-CF.Origin   = \"@\" Var-CF\n\ncontext-free syntax\n\n  MessageContent.NoMessage =\n  MessageContent           = Str\n\n  MessageContentPart.Term = &lt;[&lt;Term&gt;]&gt;\n  MessageContentPart.Text = MessageChars\n\nlexical syntax\n\n  MessageChars = MessageChar+\n  MessageChar  = ~[\\[\\]\\\\\\t\\r\\n]\n  MessageChar  = \"\\\\[\" | \"\\\\]\" | \"\\\\n\" | \"\\\\r\" | \"\\\\t\" | \"\\\\\\\\\"\n\nlexical restrictions\n\n  MessageChars -/- ~[\\[\\]]\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Core.sdf3/#modal-h2","title":"Core.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Deprecated.sdf3/","title":"<code>Deprecated.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Deprecated.sdf3</p> <pre><code>module statix/lang/Deprecated\n\nimports\n\n  statix/lang/Common\n  statix/lang/Core\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\n/******************************************************************\n * Filtering\n ******************************************************************/\n\ncontext-free syntax\n\n  QueryFilter.Filter_dep = &lt; filter pathMatch[&lt;LabelRE&gt;]&gt; {deprecated(\"Use 'filter RE' instead of 'filter pathMatch[RE]'\")}\n  QueryMin.Min_dep       = &lt; min pathLt[&lt;LabelPairs&gt;]&gt;    {deprecated(\"Use 'min LT' instead of 'min pathLt[LT]'\")}\n\n  QueryFilter.Filter_dep = &lt; filter pathMatch[&lt;LabelRE&gt;] and &lt;HoConstraint&gt;&gt; {deprecated(\"Use 'filter RE' instead of 'filter pathMatch[RE]'\")}\n  QueryMin.Min_dep       = &lt; min pathLt[&lt;LabelPairs&gt;] and &lt;HoConstraint&gt;&gt;    {deprecated(\"Use 'min LT' instead of 'min pathLt[LT]'\")}\n\n  NamespaceFilter.NamespaceFilter_dep = &lt; filter pathMatch[&lt;LabelRE&gt;]&gt; {deprecated(\"Use 'filter RE' instead of 'filter pathMatch[RE]'\")}\n  NamespaceMin.NamespaceMin_dep       = &lt; min pathLt[&lt;LabelPairs&gt;]&gt;    {deprecated(\"Use 'min LT' instead of 'min pathLt[LT]'\")}\n\n/******************************************************************\n * Scope Graph creation\n ******************************************************************/\n\ncontext-free syntax\n\n  // namespaces\n  Signature.Namespaces = &lt;\n    namespaces\n      &lt;{NsDecl \"\\n\"}*&gt;\n  &gt; {longest-match, deprecated(\"Usage of namespaces is strongly discouraged.\")}\n\n  NsDecl.NsDecl = &lt;&lt;NamespaceId&gt; : &lt;{SortRef \" * \"}*&gt;&gt; {deprecated(\"Usage of namespaces is strongly discouraged.\")}\n\n  Rule = &lt;namespace &lt;NsDecl&gt;&gt;\n\n  // default resolution policies\n  NamespaceQuery.NamespaceQuery = &lt;resolve &lt;NamespaceId&gt;&lt;NamespaceFilter&gt;&lt;NamespaceMin&gt;&gt; {deprecated(\"Namespaces might be removed in a future version.\")}\n\n  ResolutionParam = NamespaceQuery\n  Rule            = NamespaceQuery\n\n  NamespaceFilter.NamespaceFilter   = &lt; filter &lt;LabelRE&gt;&gt;\n  NamespaceFilter.NoNamespaceFilter =\n\n  NamespaceMin.NamespaceMin   = &lt; min &lt;LabelPairs&gt;&gt;\n  NamespaceMin.NoNamespaceMin =\n\n  Constraint.CTellDecl         = [[Term] -&gt; [Occurrence]] {deprecated(\"Occurrences might be removed in a future version. Use `!rel[...]` syntax instead.\")}\n  Constraint.CTellDeclWithRels = [[Term] -&gt; [Occurrence] with [{RelData \" and \"}+]] {deprecated(\"Occurrences might be removed in a future version. Use `!rel[...]` syntax instead.\")}\n\n  RelData = [[RelRef] [Term]]\n\n/******************************************************************\n * Resolve &amp; Query\n ******************************************************************/\n\ncontext-free syntax\n\n  Constraint.CResolveRef        = [[Occurrence] in [Term] |-&gt; [Term][Message]]             {deprecated(\"Occurrences might be removed in a future version. Use `query` syntax instead.\")}\n  Constraint.CResolveRefWithRel = [[RelRef] of [Occurrence] in [Term] |-&gt; [Term][Message]] {deprecated(\"Occurrences might be removed in a future version. Use `query` syntax instead.\")}\n\n  // little duplication to fix ambiguity between\n  // As(Var(_),Var(_)), NoId() and Var(_), WithId(Var(_))\n  OccurrenceTerm  = Term {longest-match}\n  OccurrenceTerm  = &lt;&lt;Var&gt;@&lt;Term&gt;&gt; {reject}\n  OccurrenceTerms = &lt;&lt;{OccurrenceTerm \" \"}*&gt;&gt;\n\n  Term = Occurrence\n\n  Occurrence = OccurrenceLit // this indirection is necessary to solve parse errors\n\nsyntax\n\n  OccurrencePosition-CF.NoId   =\n  OccurrencePosition-CF.WithId = \"@\" TermOrTermIndex-CF\n  OccurrencePosition-CF.NoId   = \"@-\"\n\n  OccurrenceLit-CF.StxOccurrence = NamespaceId-LEX \"{\" LAYOUT?-CF OccurrenceTerms-CF LAYOUT?-CF OccurrencePosition-CF LAYOUT?-CF \"}\" {deprecated(\"Usage of occurrences is strongly discouraged.\")}\n\n  LabelRE-CF.ResolveMatch = \"resolveMatch\" \"[\" LAYOUT?-CF Occurrence-CF LAYOUT?-CF  \"]\"           {deprecated(\"Occurrences might be removed in a future version.\")}\n\n  LabelOrd-CF.ResolveLt = \"resolveLt\" \"[\" LAYOUT?-CF Occurrence-CF LAYOUT?-CF \"]\"                 {deprecated(\"Occurrences might be removed in a future version.\")}\n\n  HoConstraint-CF.OccurrenceMatch = \"occurrenceMatch\" \"[\" LAYOUT?-CF Occurrence-CF LAYOUT?-CF \"]\" {deprecated(\"Occurrences might be removed in a future version.\")}\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Deprecated.sdf3/#modal-h2","title":"Deprecated.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Layout.sdf3/","title":"<code>Layout.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Layout.sdf3</p> <pre><code>module statix/lang/Layout\n\nlexical syntax\n\n  LAYOUT = [\\t\\ \\r\\n]\n  LAYOUT = LineComment\n  LAYOUT = BlockComment\n\n  EOF =  \n\n  LineComment     = \"//\" ~[\\r\\n]* ([\\r\\n] | EOF)\n\n  BlockComment    = \"/*\" CommentText (BlockComment CommentText)* (\"*/\" | EOF)\n  CommentText     = CommentChar*\n  CommentChar     = ~[\\*\\/] | CommentAsterisk | CommentSlash\n  CommentSlash    = \"/\"\n  CommentAsterisk = \"*\"\n\nlexical restrictions\n\n  EOF             -/- ~[]\n  CommentText     -/- ~[\\*\\/]\n  CommentAsterisk -/- [\\/]\n  CommentSlash    -/- [\\*]\n\ncontext-free restrictions\n\n  LAYOUT? -/- [\\ \\t\\r\\n]   // whitespace\n  LAYOUT? -/- [\\/].[\\/]    // line comment start\n  LAYOUT? -/- [\\/].[\\*]    // block comment start\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Layout.sdf3/#modal-h2","title":"Layout.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/NoParse.sdf3/","title":"<code>NoParse.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/NoParse.sdf3</p> <pre><code>module statix/lang/NoParse // DO NOT INCLUDE IN OTHER SYNTAX FILES\n\nimports\n\n  statix/lang/Common\n  statix/lang/Core\n  statix/lang/Sugar\n\n  statix/API\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\ncontext-free syntax // desugared terms\n\n  Term.Tuple = &lt;(&lt;{Term \", \"}*&gt;)&gt;\n\n  SortRef.TupleSort = &lt;(&lt;{SortRef \" * \"}*&gt;)&gt;\n\n  Lift.TupleLift = &lt;(&lt;{Lift \", \"}*&gt;)&gt;\n\ncontext-free syntax // runtime terms\n\n  Term = Label\n  Term = Stx-Scope\n  Term = Stx-TermIndex\n\n  TermOrTermIndex = Stx-TermIndex\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/NoParse.sdf3/#modal-h2","title":"NoParse.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/PreCompiled.sdf3/","title":"<code>PreCompiled.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/PreCompiled.sdf3</p> <pre><code>module statix/lang/PreCompiled\n\nimports\n\n  statix/lang/Common\n  statix/lang/Core\n\nlexical sorts\n\n  ENVID\n\ncontext-free sorts\n\n  PreCompiledQuery\n\n  State\n  StateId\n  StateRef\n\n  RStep\n  RExp\n  RVar\n  RCond\n\nlexical syntax\n\n  ENVID = [a-zA-Z] [a-zA-Z0-9\\$\\_\\-]*\n\nlexical restrictions\n\n  ENVID -/- [a-zA-Z0-9\\$\\_\\-]\n\ncontext-free syntax\n\n  Constraint.CPreCompiledQuery = [\n    compiled [CResolveQuery]\n    to\n      states\n        [{State \"\\n\\n\"}*]\n\n      initial [StateRef]\n  ]\n\n\ncontext-free syntax // States\n\n  State.State = &lt;\n    &lt;StateId&gt;:\n      &lt;{RStep \"\\n\"}+&gt;\n      return &lt;RVar&gt;\n  &gt;\n\n  StateId  = LCID\n  StateRef = LCID\n\ncontext-free syntax // Resolution steps\n\n  RStep.Step     = &lt;&lt;RVar&gt; := &lt;RExp&gt;&gt;\n\ncontext-free syntax // Resolution expressions\n\n  RExp.Resolve   = &lt;resolve&gt;\n\n  RExp.SubEnv    = &lt;subenv &lt;RelRef&gt; &lt;StateRef&gt;&gt;\n\n  RExp.Merge     = &lt;merge(&lt;{RVar \", \"}*&gt;)&gt;\n\n  RExp.Shadow    = &lt;shadow(&lt;RVar&gt;, &lt;RVar&gt;)&gt;\n\n  RExp.CExp      = &lt;if not empty &lt;RVar&gt; else &lt;RExp&gt;&gt;\n\n  RVar.RVar      = ENVID\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/PreCompiled.sdf3/#modal-h2","title":"PreCompiled.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Schema.sdf3/","title":"<code>Schema.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Schema.sdf3</p> <pre><code>module statix/lang/Schema\n\nimports\n  statix/lang/Common\n  statix/lang/Core\n\ncontext-free start-symbols\n\n  Schema\n\ncontext-free sorts\n\n  Schema\n\ncontext-free syntax\n\n  Schema.SGSchema = &lt;scope graph scheme\n    &lt;SGEdges&gt;\n\n    &lt;SGDecls&gt;\n\n    &lt;SchemaVars&gt;\n  &gt;\n\ncontext-free sorts\n  SGEdges\n  SGEdge\n\ncontext-free syntax\n\n  SGEdges.SGEdges = &lt;edges\n    &lt;{SGEdge \"\\n\"}*&gt;\n  &gt;\n\n  SGEdge.SGEdge = [{[{ScopeKindWithCard \", \"}*]} =[Label]=&gt; {[{ScopeKindWithCard \", \"}*]} in [RuleName]]\n\ncontext-free sorts\n\n  SGDecls\n  SGDecl\n  Data\n\ncontext-free syntax\n\n  SGDecls.SGDecls = &lt;decls\n    &lt;{SGDecl \"\\n\"}*&gt;\n  &gt;\n\n  SGDecl.SGDecl = [{[{ScopeKindWithCard \", \"}*]} |=[Label]=&gt; \\[[{Data \", \"}*]\\] in [RuleName]]\n\n  Data.DData  = &lt;data&gt;\n  Data.DScope = [scope {[{ScopeKindWithCard \", \"}*]}]\n\ncontext-free sorts\n\n  SchemaVars\n  SchemaVar\n\ncontext-free syntax\n\n  SchemaVars.SchemaVars = &lt;schema variables\n    &lt;{SchemaVar \"\\n\"}*&gt;\n  &gt;\n\n  SchemaVar.SchemaVar = [[ScopeKindVar] |-&gt; {[{ScopeKindWithCard \",\"}*]}]\n\ncontext-free sorts\n\n  ScopeKind\n  ScopeKindVar\n  ScopeKindWithCard\n\ncontext-free syntax\n\n  ScopeKind.Glob         = &lt;glob&gt;\n  ScopeKind.KVar         = &lt;var &lt;Var&gt;&gt;\n  ScopeKind.Unknown      = &lt;unknown&gt;\n\n  ScopeKindVar.Variable  = &lt;var &lt;Var&gt;&gt;\n  ScopeKindVar.PArg      = &lt;prd &lt;ConstraintId&gt;[&lt;INTT&gt;]&gt;\n  ScopeKindVar.CArg      = &lt;ctr &lt;SortId&gt;[&lt;INTT&gt;]&gt;\n  ScopeKindVar.RArg      = &lt;rel &lt;Label&gt;[&lt;INTT&gt;]&gt;\n\n  ScopeKindWithCard.ScopeKindWithCard = &lt;&lt;ScopeKind&gt;[&lt;Cardinality&gt;]&gt;\n\ncontext-free sorts\n\n  Cardinality\n  Bound\n\ncontext-free syntax\n\n  Cardinality.Cardinality = &lt;&lt;Bound&gt;..&lt;Bound&gt;&gt;\n  Bound.INF               = &lt;*&gt;\n  Bound.BNum              = &lt;&lt;INTT&gt;&gt;\n\nlexical sorts\n  INTT\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Schema.sdf3/#modal-h2","title":"Schema.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Sugar.sdf3/","title":"<code>Sugar.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Sugar.sdf3</p> <pre><code>module statix/lang/Sugar\n\nimports\n\n  statix/lang/Common\n  statix/lang/Core\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\n\n/******************************************************************\n * User Constraints                                               *\n ******************************************************************/\n\ncontext-free syntax\n\n  // lifting of constraints\n\n  Rule             = &lt;constraint &lt;CDerive&gt;&gt;\n  Rule             = CDerive\n\n  Rule.CDecl       = [[CInd]constraint [ConstraintId] : [Type]]\n  Rule.CDecl       = [[CInd][ConstraintId] : [Type]]\n\n  CDecl            = CDerive\n\n  CDerive.CDeriveMap = [[ConstraintId] maps [ConstraintId]([{Lift \", \"}*])]\n  CDerive.FDeriveMap = [[ConstraintId] maps [ConstraintId]([{Lift \", \"}*]) = [Lift]]\n\n  Lift.IdLift     = \"*\"\n  Lift.ListLift   = \"list(*)\"\n  Lift.Tuple0Lift = &lt;( )&gt;\n  Lift.TupleNLift = &lt;(&lt;Lift&gt;, &lt;{Lift \", \"}+&gt;)&gt;\n\n  // rule shorthands\n\n  Rule.AxiomRule = &lt;\n    &lt;RuleName&gt;&lt;RuleHead&gt;.\n  &gt;\n\n  RuleHead.F = [[ConstraintId]([{Term \", \"}*]) = [Term]]\n\n  HoConstraint.LLam = &lt;{ &lt;{Term \", \"}+&gt; }&gt;\n\n  HoConstraint.LC = ConstraintId\n\n  HoConstraint.EQ = &lt;eq(&lt;Term&gt;)&gt;\n\nsyntax\n\n  Term-CF.COp = ConstraintId-CF \"(\" LAYOUT?-CF CommaTerms-CF LAYOUT?-CF \")\"\n\nlexical syntax\n\n  Keyword = \"constraint\" | \"maps\"\n\n\n/******************************************************************\n * Base Constraints                                               *\n ******************************************************************/\n\ncontext-free syntax\n\n  HoConstraint.LTrue  = \"true\"\n  HoConstraint.LFalse = \"false\"\n\n  Term.NewOp   = \"new\"\n  Term.AstIdOp = &lt;astId(&lt;Term&gt;)&gt;\n\n  AstProperty.Ref  = \"ref\"\n  AstProperty.Type = \"type\"\n\nlexical syntax\n\n  VARID = \"new\" {reject}\n\n  AstPropertyId = \"ref\" | \"type\" {reject}\n\n\n/******************************************************************\n * Relations                                                      *\n ******************************************************************/\n\ncontext-free syntax\n\n  RelRef.Decl = \"decl\"\n\nsyntax\n\n  // short-hand for querying relations\n\n  Constraint-CF.CAskRel  = \"?\" RelRef-CF \"[\" CommaTerms-CF \"]\" LAYOUT?-CF \"in\" LAYOUT?-CF Term-CF LAYOUT?-CF Message-CF\n\n  Term-CF.AskRelOp = \"?\" RelRef-CF \"[\" LAYOUT?-CF CommaTerms-CF LAYOUT?-CF \"]\" LAYOUT?-CF \"in\" LAYOUT?-CF Term-CF\n\nlexical syntax\n\n  RelationId = \"decl\" {reject}\n  RelationId = \"ref\" {reject}\n\n\n/******************************************************************\n * Scope Graph                                                    *\n ******************************************************************/\n\ncontext-free syntax\n\n  LabelRE.ZeroOrOne = &lt;&lt;LabelRE&gt;?&gt;\n  LabelRE.OneOrMore = &lt;&lt;LabelRE&gt;+&gt;\n\ncontext-free priorities\n\n    { LabelRE.Neg LabelRE.Closure LabelRE.ZeroOrOne LabelRE.OneOrMore }\n  &gt; { LabelRE.Concat LabelRE.And LabelRE.Or }\n\nlexical syntax\n\n  Keyword = \"resolve\" | \"filter\" | \"with\" | \"and\"\n\n\n/******************************************************************\n * Resolve &amp; Query\n ******************************************************************/\n\ncontext-free syntax\n\n  // short-hand forms for occurrences using default resolution policies\n\n  QueryFilter.NoFilter =\n  QueryFilter.Filter   = &lt; filter &lt;LabelRE&gt;&gt;\n\n\n  QueryMin.NoMin =\n  QueryMin.Min   = &lt; min &lt;LabelOrd&gt;&gt;\n\n\n  QueryProject.NoProject =\n\nlexical syntax\n\n  Keyword = \"filter\" | \"min\" | \"in\" | \"of\" | \"resolveMatch\" | \"resolveLt\" | \"occurrenceMatch\"\n\n\n/******************************************************************\n * Sorts &amp; Constructors                                           *\n ******************************************************************/\n\ncontext-free syntax\n\n  Type.FunType    = [[{SortRef \" * \"}*] -&gt; [SortRef]]\n\n\n/******************************************************************\n * Terms                                                          *\n ******************************************************************/\n\n\n/******************************************************************\n * Arithmetic                                                          *\n ******************************************************************/\n\nsyntax\n\n  Term-CF.ArithOp = \"#\" \"(\" LAYOUT?-CF ArithExp-CF LAYOUT?-CF \")\"\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Sugar.sdf3/#modal-h2","title":"Sugar.sdf3","text":""},{"location":"statix.lang/syntax/statix/lang/Type.sdf3/","title":"<code>Type.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/lang/Type.sdf3</p> <pre><code>module statix/lang/Type\n\nimports\n\n  nabl2/API\n\n  statix/lang/Common\n  statix/lang/Core\n\n  statix/API\n\nsorts\n\n  IType // internal type\n  TType // term type\n\ncontext-free syntax\n\n  IType.PRED = [[TTypes]]\n  IType.FUN  = [[TTypes] -&gt; [TType]]\n  IType.NS   = [[TTypes]]\n  IType.OP   = [[TTypes] -&gt; [TType]]\n\n  TTypes = {TType \" * \"}*\n\n  TType.SORT       = &lt;&lt;NaBL2Occurrence&gt;&gt;\n  TType.INT        = &lt;int&gt;\n  TType.STRING     = &lt;string&gt;\n  TType.PATH       = &lt;path&gt;\n  TType.LABEL      = &lt;label&gt;\n  TType.OCCURRENCE = &lt;occurrence&gt;\n  TType.AST_ID     = &lt;astId&gt;\n  TType.SCOPE      = &lt;scope&gt;\n  TType.LIST       = &lt;list(&lt;TType&gt;)&gt;\n  TType.TUPLE      = &lt;(&lt;TTypes&gt;)&gt;\n\nsorts\n\n  ExtOrigin // custom prettyprint rule in statix/lang/scope-extension.str\n\ncontext-free syntax\n\n  ExtConstraints = &lt;| &lt;{ExtConstraint \"\\n\"}*&gt;&gt;\n\n  ExtConstraint.ExtProvides  = [[ExtSet] ! [ExtSet][ExtOrigin]]\n  ExtConstraint.ExtRequires  = [[ExtSet] ? [ExtSet][ExtOrigin]]\n  ExtConstraint.ExtIsCovered = [[ExtSet] is closed[ExtOrigin]]\n  ExtConstraint.ExtProvidesEsc  = [[ExtSet] ^! [ExtSet][ExtOrigin]]\n  ExtConstraint.ExtRequiresEsc  = [[ExtSet] ^? [ExtSet][ExtOrigin]]\n\n\n  ExtSets = &lt;| &lt;{ExtSet \"\\n\"}*&gt;&gt;\n\n  ExtSet.ExtParam = [[ExtId].[Stx-INT]]\n  ExtSet.ExtVar   = [[ExtId]]\n  ExtSet.ExtLit   = [{[{ExtLabel \", \"}*]}]\n  ExtSet.ExtAll   = \"*\"\n  ExtSet.ExtNone  = \"0\"\n\n\n  ExtId.ExtRef  = &lt;ref &lt;NaBL2Occurrence&gt;&gt;\n  ExtId.ExtDecl = &lt;decl &lt;NaBL2Occurrence&gt;&gt;\n\n\n  ExtLabel = RelRef\n  ExtLabel = EdgeRef\n\n\n  ExtEqs = &lt;| &lt;{ExtEq \"\\n\"}*&gt;&gt;\n\n  ExtEq = [[ExtSet] := [ExtOp]]\n\n\n  ExtOp.Union        = [union([{ExtOp \", \"}*])]\n  ExtOp.Intersection = [isect([{ExtOp \", \"}*])]\n  ExtOp              = ExtSet\n\ncontext-free syntax\n\n  PatternConstraint.DistinctPatterns = &lt;distinct patterns &lt;{NaBL2Occurrence \", \"}*&gt;&gt;\n  PatternConstraint.NoDuplicatePatterns = &lt;patterns {&lt;{NaBL2Occurrence \", \"}*&gt;} do not duplicate {&lt;{NaBL2Occurrence \", \"}*&gt;} &lt;ExtOrigin&gt;&gt;\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/lang/Type.sdf3/#modal-h2","title":"Type.sdf3","text":""},{"location":"statix.lang/syntax/statix/test/Result.sdf3/","title":"<code>Result.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/test/Result.sdf3</p> <pre><code>module statix/test/Result\n\nimports\n\n  statix/API\n\n  statix/lang/Layout\n  statix/lang/Common\n  statix/lang/Core\n  statix/lang/Sugar\n  statix/lang/Deprecated\n\n  statix/runtime/ATerm\n  statix/runtime/ScopeGraph\n\n\ncontext-free syntax\n\n  TestResult.EvalResult = &lt;\n    &lt;Solution&gt;\n\n    errors\n      &lt;{EditorMessage \"\\n\"}*&gt;\n\n    warnings\n      &lt;{EditorMessage \"\\n\"}*&gt;\n\n    notes\n      &lt;{EditorMessage \"\\n\"}*&gt;\n  &gt;\n\n  Solution.Solution = &lt;\n    substitution\n      &lt;{SubstEntry \"\\n\"}*&gt;\n\n    &lt;Analysis&gt;\n  &gt;\n\ncontext-free syntax\n\n  // special pretty print rule in statix/runtime/pp to support printing blob analyses too\n\n  Analysis.Analysis = &lt;\n    analysis\n      &lt;Stx-ScopeGraph&gt;\n  &gt;\n\ncontext-free syntax\n\n  SubstEntry = [[Var] |-&gt; [Stx-ATerm]]\n\ncontext-free syntax\n\n  EditorMessage = [[MessagePos] : [Stx-STRING]]\n\n  MessagePos = \"*\"\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/test/Result.sdf3/#modal-h2","title":"Result.sdf3","text":""},{"location":"statix.lang/syntax/statix/test/Test.sdf3/","title":"<code>Test.sdf3</code>","text":"<p> pdmosses/nabl/statix.lang/syntax/statix/test/Test.sdf3</p> <pre><code>module statix/test/Test\n\nimports\n\n  statix/lang/Layout\n  statix/lang/Common\n  statix/lang/Core\n  statix/lang/Sugar\n  statix/lang/Deprecated\n\ntemplate options\n\n  keyword -/- [a-zA-Z0-9\\_\\-\\']\n\ncontext-free start-symbols\n\n  Test\n\ncontext-free syntax\n\n  Test.Test = &lt;\n    resolve\n      &lt;Constraint&gt;\n\n    &lt;{Section \"\\n\\n\"}*&gt;\n  &gt;\n\n</code></pre> \u00d7"},{"location":"statix.lang/syntax/statix/test/Test.sdf3/#modal-h2","title":"Test.sdf3","text":""}]}